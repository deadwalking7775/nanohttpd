---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wangzixiao.
--- DateTime: 2020/3/12 9:33 下午
---


prodEnv = true
localPath = scriptPath()

---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wzx.
--- DateTime: 2019-06-12 18:52
---


function getDealerPos(regionDealers)
    local dealerPos = -1
    for i, r in ipairs(regionDealers) do
        if r:exists(dealerPattern,0) then
            dealerPos = i
            return dealerPos
        end
    end
    return dealerPos
end

function getHandsWithRegions(regionCard1type, regionCard2type, regionCard1num, regionCard2num)
    local num2Prefix = ""
    local type2Prefix = ""
    if platform == "yhpk" then
        num2Prefix = "r-"
        type2Prefix = "r-"
    end

    local type1 = getCardType(regionCard1type)
    local type2 = getCardTypeRight(regionCard2type)

    local num1 = getCardNum(regionCard1num, type1, "")
    local num2 = getCardNum(regionCard2num, type2, num2Prefix)


    local handsType = getHandsType(type1, type2, num1, num2)
    local cardInfo = getCardNumChar(num1)..getCardNumChar(num2)
            ..getCardTypeChar(type1)..getCardTypeChar(type2)
    return type1,type2,num1,num2,handsType,cardInfo
end



function checkAofHandAndTable(getTable, newPlayerChips, newTablePlayerPreciseChips, bbSize, newDealerPosition, playersExists)
    local type1,type2,num1,num2,handsType,cardInfo =
    getHandsWithRegions(regionCard1type, regionCard2type, regionCard1num, regionCard2num)
    local playersStatus, exists = getPlayerStatus(playersExists, regionPlayerStatus, regionPlayerChipSlot)

    local dealerPosition = -1
    if getTable then
        dealerPosition = newDealerPosition
    else
        dealerPosition = getDealerPos(regionDealerList)
    end


    local playerChips = {}
    local tablePlayerPreciseChips = {}
    if getTable then
        playerChips = newPlayerChips
        tablePlayerPreciseChips = newTablePlayerPreciseChips
    else
        playerChips,tablePlayerPreciseChips = getPlayerChipV2(bbSize, playersExistsTable)
    end

    return type1,type2,num1,num2,handsType,cardInfo,dealerPosition,playersStatus,exists,playerChips,tablePlayerPreciseChips
end


function aofMainLoop(endTime)
    local currentDealerPosition = -1
    local bbSize = -1
    local tick = 0
    local getTable = false
    local sendTableLog = false
    local newTable = true
    local takeAction = false
    local currentPlayerChips = { 1, 1, 1, 1}
    local currentPlayerPreciseChips = { 8, 8, 8, 8}
    --local playersExistsTable
    local handsCnt = 0
    local handsCntPrecise = 0
    local lastRoundTime = os.time()
    local headsUpCount = 0
    local getOntableNum = 0
    local friendsExist = false
    toast("mainloop start", 3)

    while(1) do
        -- dealer 消失， 先看bb size
        if newTable or debugMode then
            local newBbSize = getBlindSize(regionBlindSize, tick, bbSize)
            if newBbSize ~= nil and newBbSize ~= -1 then
                bbSize = newBbSize
                newTable = false
            end
            playersExistsTable = { true, true, true, true }
        end

        -- dealer位置变了, new round
        -- 无人上桌dealer也会消失
        if (currentDealerPosition == -1 or not regionDealerList[currentDealerPosition]:exists(dealerPattern, 0) or debugMode) then
            local newDealerPosition = getDealerPos(regionDealerList)

            if handsCntPrecise%10 == 0 then
                friendsExist = checkFriendsExist()
            end

            LogFile("newDealerPosition: "..newDealerPosition)

            if newDealerPosition ~= -1 then
                currentDealerPosition = newDealerPosition

                if platform == "yhpk" then
                    wait(0.5)
                    playersExistsTable = getPlayerExists(regionPlayerChipSlot, regionPlayerStatus)
                end

                currentPlayerChips, currentPlayerPreciseChips = getPlayerChipV2(bbSize, playersExistsTable)
                getTable = true
                sendTableLog = false
                takeAction = false
                handsCntPrecise = handsCntPrecise+1
            else
                -- dealer 消失， 先看bb size
                newTable = true
            end

            if debugMode then
                currentPlayerChips, currentPlayerPreciseChips = getPlayerChipV2(bbSize, playersExistsTable)
            end

            local playerNum = 0
            for i, v in pairs(playersExistsTable) do
                if v then
                    playerNum = playerNum+1
                end
            end

            if playerNum == 2 then
                headsUpCount = headsUpCount + 1
            else
                headsUpCount = 0
            end
        end

        if getTable or platform == "ppk" then
            -- 牌上手之后操作
            if (regionAllInButton:exists(patternAllInButton, 0)) then
                --r egionAllInButton:highlight(3)
                wait(0.3)
                local type1,type2,num1,num2,handsType,cardInfo,dealerPosition,playersStatus,exists,playerChips,tablePlayerPreciseChips =
                checkAofHandAndTable(getTable, currentPlayerChips, currentPlayerPreciseChips, bbSize, currentDealerPosition, playersExistsTable)

                playersExistsTable = exists


                local doThing = "f"
                local ev
                if version2Mode then
                    -- cal V2 --
                    ev = getV2Action(handsType, playersStatus, dealerPosition, tablePlayerPreciseChips, bbSize)
                    if ev ~= nil then
                        if ev > 0 then
                            doThing = "a"
                        end
                    end
                end

                local range = getHandsV1Range(num1,num2,type1,type2, playersStatus)
                local tableRange = getTableV1Range(playersStatus, playerChips)


                if not version2Mode or ev == nil then
                    -- cal V1 --
                    if allInWithRangeV1(range, tableRange, playerChips) then
                        doThing = "a"
                    end
                end

                if doThing == "a" then
                    ExistClickRandomGo(regionSmallAllInButton)
                else
                    ExistClickRandomGo(regionFoldButton)
                end

                if checkHandsSnap or tableRange == 1 then
                    Snapshot(cardInfo.."r"..range.."t"..tableRange.."_doThing_"..doThing
                            .."_playerPreciseChips_"..table.concat(tablePlayerPreciseChips, "_")
                            .."_dealer"..dealerPosition..playersStatus[1]..playersStatus[2]..playersStatus[3]..playersStatus[4]..playersStatus[5])
                end

                -- logging --
                local fullInfo = "card: "..cardInfo..", range: "..range..", table: "..tableRange..", do: ".. doThing
                        ..", playerChips: "..table.concat(playerChips)
                        ..", playerPreciseChips: "..table.concat(tablePlayerPreciseChips, " ")
                        ..", players: "..table.concat(playersStatus)
                        ..", dealerPos: "..dealerPosition
                        ..", getHands: "..bool_to_string[getTable].." handsType: "
                        ..", playersExistsTable "..bool_to_string[playersExistsTable[1]]..bool_to_string[playersExistsTable[2]]..bool_to_string[playersExistsTable[4]]
                        ..", handsType:"..handsType

                LogFile(fullInfo);
                lastRoundTime = os.time()
                if debugLogEnable then
                    toast(fullInfo,3)
                end
                --if range > tableRange and doThing == "a" then
                --    errorLog("range loose than standard"..fullInfo)
                --elseif range < tableRange and doThing == "f" then
                --    errorLog("range tight than standard"..fullInfo)
                --end
                --if timeConsumeLog then
                --    LogFile("Time: "
                --            .."， Card: "..string.format("%.3f",timeGetCard-timeStart)
                --            ..", Dealer: "..string.format("%.3f",timeGetDealer-timeGetCard)
                --            ..", Player: "..string.format("%.3f",timeGetPlayer-timeGetDealer)
                --            ..", Strategy: "..string.format("%.3f",timeStrategy-timeGetPlayer)
                --            ..", Total: "..string.format("%.3f",timeStrategy-timeStart))
                --end

                getTable = false
                takeAction = true
                handsCnt = handsCnt+1
                --toast(handsCnt)
            end

        end


        if debugLogEnable then
            --toast("test", 0.3)
        end
        wait(0.3)

        tick = tick+1



        -- - --- do log ---------
        if (getTable and not sendTableLog) or debugMode then
            if checkTableSnap then
                Snapshot("table_"..os.date("%b%d%H%M%S").."_".. currentPlayerPreciseChips[1].."_".. currentPlayerPreciseChips[2].."_"
                        .. currentPlayerPreciseChips[3].."_".. currentPlayerPreciseChips[4])
            end
            if autoHandTestMode then
                LogFile(table.concat(currentPlayerChips))
            else
                LogFile("hands playerChips: "..table.concat(currentPlayerChips, " ")
                        .." playerPreciseChips: "..table.concat(currentPlayerPreciseChips, " ")
                        ..", dealer: ".. currentDealerPosition
                        ..", BB: "..bbSize)
            end
            sendTableLog = true
        end


        --if avoidHeadsUp and headsUpCount >= 20 then
        --    local nextRoundWaitTimeMinute = 15
        --    LogFile("headsUpCount reach limit 20")
        --    return "headsUpCount reach limit 20", handsCntPrecise, nextRoundWaitTimeMinute
        --end

        if friendsExist then
            LogFile("friendsExist quit")
            return "friendsExist quit", handsCntPrecise, nextRoundWaitTimeMinute
        end

        if os.time() > endTime then
            LogFile("endTime reach "..endTime)
            --httpGet("https://maker.ifttt.com/trigger/autoBotTest/with/key/nfeLorbq9gn25evEb8mS_2N0QDwxcG6JUHMwShgM9w1?value1="..playerId.."_endTime_reach_"..endTime)
            return "endTime reach "..endTime,handsCntPrecise
        end

        -- 上桌检测
        if os.time() > (lastRoundTime+100) then
            existsClick(chipSlotImg, 0)
            getOntableNum = getOntableNum+1
            if getOntableNum >= 3 then
                return "不能上桌",handsCntPrecise,120
            end
        end

        if os.time() > (lastRoundTime+600) then
            LogFile("10分钟 不打自动换桌")
            --httpGet("https://maker.ifttt.com/trigger/autoBotTest/with/key/nfeLorbq9gn25evEb8mS_2N0QDwxcG6JUHMwShgM9w1?value1="..playerId.."_endTime_reach_"..endTime)
            return "10分钟 不打自动换桌",handsCntPrecise
        end

        if maxPlayHands ~= 0 and handsCntPrecise > maxPlayHands then
            return "maxHands reach "..maxPlayHands,handsCntPrecise
        end

        if os.date("%H")==string.format("%d", shutDownHour)then
            return "endTimeReach "..shutDownHour,handsCntPrecise
        end
    end
end

function updateTableAndBlind() end

function updateDealer() end
local FRIENDS_ACCOUNT_NUM = 0
local FRIENDS_PATH_NAME = "account/account_img_"

local bool_to_string={ [true]="true", [false]="false" }

function friendsAccountInit()
	for i = 1, 100 do
		local file = io.open(localPath.."image/"..FRIENDS_PATH_NAME..i..".png", "r")
		if file == nil then
			FRIENDS_ACCOUNT_NUM = i-1
			break
		else
			io.close(file)
		end

	end
	LogFile("FRIENDS_ACCOUNT_NUM "..FRIENDS_ACCOUNT_NUM)
	toast("account num "..FRIENDS_ACCOUNT_NUM, 3)
end


function checkFriendsExist()
	Settings:set("MinSimilarity", 0.85)
	local startTime = os.clock()
	local friendOnTable = false
	local friendNum = -1 --计数
	local friendPos
	local checkPos = {1,2,4}

	if FRIENDS_ACCOUNT_NUM > 0 then
		for i, pos in ipairs(checkPos) do
			if regionPlayerName[pos]:exists(FRIENDS_PATH_NAME.."1.png", 0) then
				friendOnTable = true
				friendPos = pos
				friendNum = 1
				break
			end
		end
	end

	if not friendOnTable then
		usePreviousSnap(true)
		for i = 2, FRIENDS_ACCOUNT_NUM, 1 do
			for _, pos in ipairs(checkPos) do
				if regionPlayerName[pos]:exists(FRIENDS_PATH_NAME.."1.png", 0) then
					friendOnTable = true
					friendPos = pos
					friendNum = i
					break
				end
			end
			--friendNum = i
			--friendOnTable = friendOnTable or regionPlayerName[1]:exists(FRIENDS_PATH_NAME..i..".png", 0)
			--friendOnTable = friendOnTable or regionPlayerName[2]:exists(FRIENDS_PATH_NAME..i..".png", 0)
			--friendOnTable = friendOnTable or regionPlayerName[4]:exists(FRIENDS_PATH_NAME..i..".png", 0)
			--
			-- --regionPlayerName[1]:save("regionPlayerName[1]"..os.date("%b%d%H%M%S")..".png")
			-- --regionPlayerName[2]:save("regionPlayerName[2]"..os.date("%b%d%H%M%S")..".png")
			-- --regionPlayerName[4]:save("regionPlayerName[4]"..os.date("%b%d%H%M%S")..".png")
			--if friendOnTable then
			--	break
			--end
		end
	end

	usePreviousSnap(false)

	local endTime = os.clock()

	LogFile("checkFriendsExist time "..(endTime-startTime))
	if friendOnTable then
		regionPlayerName[friendPos]:save("friends_num"..friendNum.."_pos_"..friendPos.."_T"..os.date("%b%d%H%M%S")..".png")
		errorLog("friends EXIST: account NO"..friendNum.." table pos "..friendPos)
		toast("friends EXIST: account NO"..friendNum.." table "..friendPos, 3)
	else
		LogFile("no friend find")
	end
	Settings:set("MinSimilarity", 0.9)
	return friendOnTable
end

function loopUntilClickAndDisappear(pattern)
	local clicked = false
	local cnt = 0
	while cnt < 100 do
		if exists(pattern) then
			existsClick(pattern,0)
			wait(1)
			clicked = true
		else
			if clicked then
				return
			end
		end
		cnt = cnt +1
	end
end



function getCardType(region)
	local res = "unknown"
	if(region:exists(patternHearts,0)) then
		return "hearts"
	else
		usePreviousSnap(true)
	end

	if(region:exists(patternDiamonds,0)) then res = "diamonds"
	elseif(region:exists(patternSpade,0)) then res = "spade"
	elseif(region:exists(patternClub,0)) then res = "club"
	else
		if debugSnap then
			region:save("cardTypeLight_getFail"..os.date("%b%d%H%M%S")..".png")
		end
	end
	usePreviousSnap(false)
	return res
end

function getCardTypeRight(region)
	local res = "unknown"
	if(region:exists(patternHeartsRight,0)) then
		return "hearts"
	else
		usePreviousSnap(true)
	end

	if(region:exists(patternDiamondsRight,0)) then res = "diamonds"
	elseif(region:exists(patternSpadeRight,0)) then res = "spade"
	elseif(region:exists(patternClubRight,0)) then res = "club"
	else
		if debugSnap then
			region:save("cardTypeRight_getFail"..os.date("%b%d%H%M%S")..".png")
		end
	end
	usePreviousSnap(false)
	return res
end



function getCardNum(region, type, prefix)
	local _prefix = prefix
	if(type == "club" or type == "spade") then
		_prefix = _prefix.."black"
	elseif(type == "diamonds" or type == "hearts") then
		_prefix = _prefix.."red"
	else
		return -1
	end

	local num1,isGetNum
	num1 = -1
	num1,isGetNum = numberOCRNoFindException(region, _prefix)
    usePreviousSnap(true)
	if(isGetNum == nil or num1<0) then
		if(region:exists(_prefix .."j.png",0)) then num1=11
		elseif(region:exists(_prefix .."q.png",0)) then num1=12
		elseif(region:exists(_prefix .."k.png",0)) then num1=13
		else num1=-1 end
	else
		if(num1==0) then num1=10
		elseif(num1==1) then num1=14 end
	end
	if num1 == -1 and debugSnap then
		region:save("cardNum_getFail"..os.date("%b%d%H%M%S")..".png")
	end
    usePreviousSnap(false)
    return num1
end


function getOnePlayerExistsYhpk(regionNameStack, regionHandsBack, i)
	if not regionNameStack:exists(chipSlot2Img,0) then
		usePreviousSnap(true)
		if not regionNameStack:exists(chipSlotImg,0)
			and not regionHandsBack:exists(handsBackImg) then
			usePreviousSnap(false)
			return false
		end
		usePreviousSnap(false)
	end
	return true
end


function getOnePlayerStatusYhpk(regionHandsBack, regionNameStack, i)
	local res = "u"
	if regionNameStack:exists(allinNotice,0) then
		res = "a"
	else
		usePreviousSnap(true)
		if not regionNameStack:exists(chipSlotImg,0) and not regionNameStack:exists(chipSlot2Img,0) then
			res = "n"
			usePreviousSnap(false)
		else
			usePreviousSnap(false)
			if not regionHandsBack:exists(handsBackImg) then
				res = "f"
			end
		end
	end
	return res
end

function getOnePlayerStatus(region, i)
	local res = "u"
	local r, g, b = getColor(region, 0)
	debugLog(string.format("status_%d_rgb_%d_%d_%d", i,r,g,b))
	if region:exists(foldNotice,0) then
		res =  "f"
	else
		usePreviousSnap(true)
		if r > 165 and b < 150 then
			res =  "a"
		elseif region:exists(waitingNotice,0) or region:exists(awayNotice,0) then
			res =  "n"
		elseif region:exists(limpNotice,0) or region:exists(callNotice,0) then
			res =  "c"
		--elseif region:exists(raiseNotice,0) or region:exists(reraiseNotice,0) then
		--	res =  "r"
		elseif debugSnap then
			region:save("getPlayerStatusFail".."_"..i.."_"..os.date("%b%d%H%M%S")..string.format("_rgb_%d_%d_%d",r,g,b)..".png")
		end
	end
	--if debugSnap then
	--	region:save("getPlayerStatusFail".."_"..i.."_"..os.date("%b%d%H%M%S")..string.format("_rgb_%d_%d_%d",r,g,b)..".png")
	--end
	usePreviousSnap(false)
	return res
end

function getStatusCheckList(dealerPosition, existsList)
	local tableCheckStatus = {false, false, false, false}

	local checkStatusStr = ""
	-- 11 different situation
	local exists = ""
	if existsList[1] then
		exists = exists.."1"
	end
	if existsList[2] then
		exists = exists.."2"
	end
	if existsList[4] then
		exists = exists.."4"
	end
	if dealerPosition==1 then
		if exists=="124" then
			checkStatusStr = "124"
		elseif exists=="12" then
			checkStatusStr = "12"
		elseif exists=="14" then
			checkStatusStr = "1"
		elseif exists=="1" then
			checkStatusStr = "1"
		end
	elseif dealerPosition==2 then
		if exists=="124" then
			checkStatusStr = "12"
		elseif exists=="24" then
			checkStatusStr = "2"
		elseif exists=="12" then
			checkStatusStr = "2"
		elseif exists=="2" then
			checkStatusStr = "2"
		end
	elseif dealerPosition==3 then
		if exists=="124" then
			checkStatusStr = "2"
		end
	elseif dealerPosition==4 then
		if exists=="24" then
			checkStatusStr = "24"
		elseif exists=="14" then
			checkStatusStr = "14"
		elseif exists=="4" then
			checkStatusStr = "4"
		end
	end
	if string.find(checkStatusStr, "1") ~= nil then
		tableCheckStatus[1] = true
	end
	if string.find(checkStatusStr, "2") ~= nil then
		tableCheckStatus[2] = true
	end
	if string.find(checkStatusStr, "4") ~= nil then
		tableCheckStatus[4] = true
	end
	return checkStatusStr, tableCheckStatus
end


--function getPlayerExist(regionPlayerChipSlot)
--	-- step 1: 排除空位
--	local playersOn = { false, false, true, false}
--	for i,s in pairs(regionPlayerChipSlot) do
--		if not s:exists(chipSlotImg,0) then
--			status[i] = noPlayer
--		end
--	end
--end

function getPlayerExists(regionPlayerChipSlot, regionHandsBack)
	local playersOn = { false, false, true, false}
	local playsNum = 0
	--if platform == "ppk" then
	--	for i,s in pairs(regionPlayerChipSlot) do
	--		if s:exists(chipSlotImg,0) then
	--			status[i] = noPlayer
	--		else
	--			status[i] = getOnePlayerStatus(regionPlayerStatus[i], i)
	--		end
	--	end
	--else
		for i,s in pairs(regionPlayerChipSlot) do
			playersOn[i] = getOnePlayerExistsYhpk(s, regionHandsBack[i], i)
		end
	--end

	return playersOn
end

function getPlayerStatus(playerExists, regionPlayerStatus, regionPlayerChipSlot, playerNum, hPos)
	local unknown = "u"
	local noPlayer = "n"
	local error = "e"

	if playerNum == nil then
		playerNum = 4
	end

	if hPos == nil then
		hPos = 3
	end
	--you are Player 3

	-- 挂机 暂离 玩家排除
	local status = {unknown, unknown, unknown, unknown}
	local playersOn = { false, false, true, false}

	--status[i] = getOnePlayerStatus(regionPlayerStatus[i], true)

	-- step 1: 排除空位
	if platform == "ppk" then
		for i,s in pairs(regionPlayerChipSlot) do

			--if debugSnap then
			--	s:save("regionPlayerChipSlot".."_"..i.."_"..os.date("%b%d%H%M%S")..".png")
			--end

			if s:exists(chipSlotImg,0) then
				status[i] = noPlayer
			else
				if debugMode then
					regionPlayerStatus[i]:highlight(0.7)
				end
				status[i] = getOnePlayerStatus(regionPlayerStatus[i], i)
			end
		end
	else
		for i,s in pairs(regionPlayerChipSlot) do
			if playerExists[i] == false then
				status[i] = noPlayer
			else
				status[i] = getOnePlayerStatusYhpk(regionPlayerStatus[i],s, i)
			end
		end
	end

	for i,s in pairs(status) do
		if s == noPlayer or s == error then
			playersOn[i] = false
		else
			playersOn[i] = true
		end
	end

	-- step:2 获取需要check的位置
	--local checkStatusStr, tableCheckStatus = getStatusCheckList(dealerPosition, playersOn)
	--
	--if debugMode then
	--	LogFile(status[1]..status[2]..status[3]..status[4])
	--	LogFile(bool_to_string[tableCheckStatus[1]]
	--			..bool_to_string[tableCheckStatus[2]]..bool_to_string[tableCheckStatus[4]]
	--			.." "..bool_to_string[playersOn[1]]..bool_to_string[playersOn[2]]..bool_to_string[playersOn[4]])
	--end

	--for i, s in pairs(status) do
	--	if s == noPlayer or s == error then
	--		playerNum = playerNum-1
	--	end
	--end

	--status[playerNum+1] = playerNum
	status[hPos] = "h"
	return status, playersOn
end

function getHandsType(type1, type2, num1, num2)
	local handsType = ""
	if num1 == num2 then
		handsType = getCardNumChar(num1)..getCardNumChar(num2)
	else
		local handsTypeNum
		if num1>num2 then
			handsTypeNum = getCardNumChar(num1)..getCardNumChar(num2)
		else
			handsTypeNum = getCardNumChar(num2)..getCardNumChar(num1)
		end
		if type1==type2 then
			handsType = handsTypeNum .."s"
		else
			handsType = handsTypeNum .."o"
		end
	end
	return handsType
end


function getBlindSize(region, tick, bbSize)
	local res = -1
	if region:exists(patternBbSize1, 0) then
		res = 1
	else
		usePreviousSnap(true)
		if region:exists(patternBbSize0_5, 0) then
			res = 0.5
		elseif region:exists(patternBbSize4, 0) then
			res = 4
		elseif region:exists(patternBbSize10, 0) then
			res = 10
		elseif region:exists(patternBbSize50, 0) then
			res = 50
		elseif region:exists(patternBbSize200, 0) then
			res = 200
		end
		usePreviousSnap(false)
	end
	return res
end

---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by yd.
--- DateTime: 2019-06-25 16:53
---

function getOnePlayerStackWithImg(locationNumPivot, minBit, maxBit, dotExist, pos)
    local stack = 0
    local realMaxBit = maxBit
    local dotInt = 0
    if dotExist then
        dotInt = 1
    end
    for bit = maxBit, minBit, -1 do
        local region,location = getStackLocationAndRegionV2(locationNumPivot, realMaxBit-bit, realMaxBit, dotExist, pos)
        local num
        --debugLog("getOnePlayerStackWithImg start")
        Settings:set("MinSimilarity", stackSimilarity)
        --local num,isGetNum = numberOCRNoFindException(region, chipNumPatternPrefix.."chip-num-")
        if pos == 3 then
            num,isGetNum = numberOCRNoFindException(region, heroStackImagePrefix.."chip-num-")
            if not isGetNum then
                num,isGetNum = numberOCRNoFindException(region, heroStackImagePrefix.."chip-num-")
            end
        else
            num,isGetNum = numberOCRNoFindException(region, chipNumPatternPrefix.."chip-num-")
            if not isGetNum then
                num,isGetNum = numberOCRNoFindException(region, chipNumPatternPrefix.."chip-num-")
            end
        end
        Settings:set("MinSimilarity", 0.9)
        if isGetNum then
            stack = stack+ num* (10^(bit-1))
            debugLog("getOnePlayerStackWithImg stack:"..stack.." pos: "..pos)
        else
            realMaxBit = realMaxBit - 1

            debugLog("getOnePlayerStackWithImg get fail pos: "..pos..", bit:"..bit)

            if stackDebugSnap then
                usePreviousSnap(true)
                region:save("OneStackImg_fail_bit"..bit.."_pos_"..pos.."_dot_"..dotInt.."_"..os.date("%b%d%H%M%S.png"))
                usePreviousSnap(false)
            end
        end

        if debugMode then
            region:highlight(0.7)
        end
    end
    debugLog("getOnePlayerStackWithImg pos:"..pos.." get:"..stack)
    return stack
end

function getStackLocationAndRegionV2(location, numShiftRight, numSize, dotExist, pos)
    local c = 1
    if pos == 3 then
         c = heroStackCoef
    end
    local regionNum
    local locationNum

    local _numSize = numSize + extraStackNum
    local _numShiftRight = numShiftRight + extraStackNum
    --local locationDot = {}
    if dotExist then
        locationNum = location:offset(-stackInterval*c *(_numSize-_numShiftRight)+ stackShiftWithDotX*c, stackShiftWithDotY*c)
    else
        locationNum = location:offset(-stackInterval*c *(_numSize/2-_numShiftRight)+ stackShiftWithOutDotX*c, stackShiftWithOutDotY*c)
    end
    --debugLog("_numSize:"..(-stackInterval *(_numSize/2-_numShiftRight)))

    regionNum = Region(locationNum, stackNumWidth*c, stackNumHeight*c)

    return regionNum, locationNum
end


function getPlayerChipV2(bbSize, playersExist)
    -- 数字中间对齐，当小数点前比小数点后多一位时,如12.5,dot位置是right1, 7.5是central
    -- chip 高度50 数字宽度20 点8~10 间隔2 整体176
    -- right1 dot x+10
    -- 中点上边缘

    -- 有dot pivot是dot 没有dot是pivot是正中间位置
    local locationNumPivot = {}
    local playerDotExist = {}
    local tablePlayerChipsV1 = { 1, 1, 1, 1}
    local tablePlayerPreciseChips = {8, 8, 8, 8}

    if platform == "yhpk" then
        return tablePlayerChipsV1,tablePlayerPreciseChips
    end

    local tmpStr = ""
    for i,e in pairs(playersExist) do
        tmpStr = tmpStr..bool_to_string[e].." "
    end

    -- step1 find dot, 如果没有dot, 找数据的起始位置
    for i,location in pairs(locationStack4Players) do
        if playersExist[i] then
            local regionToFindPlayerDot = Region(location:offset(stack4PlayersFindDotXShift,0), stack4PlayersFindDotWeight, stack4PlayersFindDotHeight)

            local findDot = false
            local dotPattern
            -- regionToFindPlayerDot:highlight(1)
            if not regionToFindPlayerDot:exists(patternPlayerChipDot, 0) then
                usePreviousSnap(true)
                if not regionToFindPlayerDot:exists(patternPlayerChipDot2, 0) then
                    findDot = false
                else
                    findDot = true
                    dotPattern = patternPlayerChipDot2
                end
                usePreviousSnap(false)
            else
                findDot = true
                dotPattern = patternPlayerChipDot
            end

            playerDotExist[i] = findDot

            if playerDotExist[i] then
                usePreviousSnap(true)
                locationNumPivot[i]= Location(regionToFindPlayerDot:find(dotPattern):getX(), location:getY())
                usePreviousSnap(false)
            else
                locationNumPivot[i] = location
            end
        else
            tablePlayerPreciseChips[i] = 0
            tablePlayerChipsV1[i] = 0
        end
    end

    -- step2 获取位数
    local min = 8*bbSize
    local max = 16*bbSize

    local maxBit = -1
    local minBit = -1

    for i = 0, 6, 1 do
        if max > 10^i then
            maxBit = i+1
        end
    end
    for i = 6, 2, -1 do
        if min < 10^i then
            minBit = i-1
        end
    end
    -- bb = 10, minbb = 8, maxbb = 16, minBit = 2, maxBit = 3
    debugLog("maxBit:"..maxBit.." minBit:"..minBit)

    for i,location in pairs(locationNumPivot) do
        tablePlayerPreciseChips[i] = math.floor(getOnePlayerStackWithImg(location, minBit, maxBit, playerDotExist[i], i)/bbSize)
        if tablePlayerPreciseChips[i] >= 12 then
            tablePlayerChipsV1[i] = 2
        else
            tablePlayerChipsV1[i] = 1
        end
    end

    return tablePlayerChipsV1,tablePlayerPreciseChips
end
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by yd.
--- DateTime: 2019-06-12 18:59
---

function Snapshot(Name)
    local A=Region(0,0,1080,1920)
    A:save("snap_"..Name.."_"..os.date("%b%d%H%M%S")..".png")
end

function LogFileRaw(info, filename)
    local file = io.open(logPath..filename..".txt", "a")
    if (file~=nil) then
        file:write(info.."\r\n")
        io.close(file)
    end
end


function debugLog(info)
    if debugLogEnable then
        LogFile("debug: "..info)
    end
end

function LogFile(info)
    if printConsole then
        print(info)
    else
        if not noLogMode then
            if not performanceLogMode then
                local file = io.open(logPath.."pk"..today..".txt", "a")
                if (file~=nil) then
                    file:write(os.date("%X").." "..info.."\r\n")
                    io.close(file)
                end
            else
                logTempTable[logCount] = os.date("%X").." "..info.."\r\n"
                logCount = logCount+1
            end
        end
    end
end


function errorLog(info)
    LogFile("error: "..info)
    if printConsole then
        print("error: "..info)
    else
        if not performanceLogMode then
            local file = io.open(logPath.."error"..today..".txt", "a")
            if (file~=nil) then
                file:write(os.date("%X").." "..info.."\r\n")
                io.close(file)
            end
        else
            logTempTable[logCount] = os.date("%X").." "..info.."\r\n"
            logCount = logCount+1
        end
    end
end


function statisticLog(info)
    LogFile("statistic: "..info)
    if printConsole then
        print("statistic: "..info)
    else
        if not performanceLogMode then
            local file = io.open(logPath.."statistic"..today..".txt", "a")
            if (file~=nil) then
                file:write(os.date("%X").." "..info.."\r\n")
                io.close(file)
            end
        else
            logTempTable[logCount] = os.date("%X").." "..info.."\r\n"
            logCount = logCount+1
        end
    end
end---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wzx.
--- DateTime: 2019-06-13 17:25
---
regionPlayerStatus = {}
regionPlayerStatus[1] = Region(566,67,72,41)
regionPlayerStatus[2] = Region(891,656,72,41)
regionPlayerStatus[4] = Region(123,656,72,41)

regionPlayerChipSlot = {}
regionPlayerChipSlot[1] = Region(460,100,166,166)
regionPlayerChipSlot[2] = Region(909,690,166,166)
regionPlayerChipSlot[4] = Region(16,697,166,166)

regionPlayerName = {}
regionPlayerName[1] = Region(441,66,200,100)
regionPlayerName[2] = Region(890,650,200,100)
regionPlayerName[4] = Region(13,650,200,100)

regionDealerList = {}
regionDealerList[1] = Region(620,260,55,55)
regionDealerList[2] = Region(845,845,55,55)
regionDealerList[3] = Region(620,1530,55,55)
regionDealerList[4] = Region(180,845,55,55)

regionBlindSize = Region(540,1150,90,40)
regionAllInButton = Region(700,1500,200,200)

regionDealer = {}
regionDealer[1] = Region(620,260,55,55)
regionDealer[2] = Region(845,845,55,55)
regionDealer[3] = Region(620,1530,55,55)
regionDealer[4] = Region(180,845,55,55)

regionCard1num = Region(425,1700,50,50)
regionCard2num = Region(540,1700,50,50)

regionCard1type = Region(452,1785,90,80)
regionCard2type = Region(567,1785,90,80)

regionFoldButton = Region(225,1550,80,80)
regionSmallAllInButton = Region(750,1550,80,80)

-- 筹码中线位置, y轴为顶部
locationStack4Players = {}
locationStack4Players[1] = Location(540,263)
locationStack4Players[2] = Location(985,854)
locationStack4Players[3] = Location(540,1603)
locationStack4Players[4] = Location(98,854)

stack4PlayersFindDotWeight = 70
stack4PlayersFindDotHeight = 46
stack4PlayersFindDotXShift = -27
stack4PlayersFindDotYShift = 0

stackInterval = 22
stackShiftWithOutDotX = -4
stackShiftWithDotX = -4
stackShiftWithOutDotY = 5
stackShiftWithDotY = 5
stackShiftHeroCoef = 1.33

stackNumHeight = 44
stackNumWidth = 30

extraStackNum = 0
heroStackCoef = 1
--local regionToFindPlayerDot = Region(region:offset(-7,0), 46, 50)

--stackNumInterval = 22
--stackNumWidth = 22
--stackNumHeight = 22
--stackNumShiftX = 1
--stackNumShiftY = 1

--local regionToFindPlayerDot = Region(region:offset(-7,0), 46, 50)
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wzx.
--- DateTime: 2019-06-13 17:25
---
platform = "ppk"
gameType = "short"

today = os.date("_%b_%d")
timeLog = 1
setHighlightStyle(0x8fffff00, true)
logCount = 0
logTempTable = {}
logBatch = 50

heroStackImagePrefix = ""
rightCardNumPrefix = ""
rightCardTypePrefix = ""

stackSimilarity = 0.75

checkButton = Pattern("check-button.png"):similar(0.7)
foldButton = Pattern("fold-button.png"):similar(0.7)
allinNotice = Pattern("all-in-notice.png"):similar(0.7)
foldNotice = Pattern("fold-notice.png"):similar(0.7)
waitingNotice = Pattern("waiting-notice.png"):similar(0.6)
awayNotice = Pattern("away-notice.png"):similar(0.7)

callNotice = Pattern("call-notice-1.png"):similar(0.6)
limpNotice = Pattern("call-notice-2.png"):similar(0.6)
reraiseNotice = Pattern("reraise-notice.png"):similar(0.6)
raiseNotice = Pattern("raise-notice.png"):similar(0.6)
chipSlotImg = Pattern("emptyPlayer.png"):similar(0.87)
dealerPattern = Pattern("dealer.png"):similar(0.5)

patternHeartsRight = Pattern("hearts.png"):similar(0.9)
patternDiamondsRight = Pattern("diamonds.png"):similar(0.95)
patternSpadeRight = Pattern("spade.png"):similar(0.95)
patternClubRight = Pattern("club.png"):similar(0.95)
patternHearts = Pattern("hearts.png"):similar(0.9)
patternDiamonds = Pattern("diamonds.png"):similar(0.95)
patternSpade = Pattern("spade.png"):similar(0.95)
patternClub = Pattern("club.png"):similar(0.95)

patternBbSize0_5 = Pattern("bb-size-0-5.png"):similar(0.8)
patternBbSize1 = Pattern("bb-size-1.png"):similar(0.9)
patternBbSize4 = Pattern("bb-size-4.png"):similar(0.9)
patternBbSize10 = Pattern("bb-size-10.png"):similar(0.8)
patternBbSize50 = Pattern("bb-size-50.png"):similar(0.8)
patternBbSize200 = Pattern("bb-size-200.png"):similar(0.8)
patternPlayerChipDot = Pattern("chip-dot.png"):similar(0.9)
patternPlayerChipDot2 = Pattern("chip-dot2.png"):similar(0.9)

chipNumPatternPrefix = ""
if thunderLog or yunkongLog then
    chipNumPatternPrefix = "leidian-"
end

if yunkongLog then
    patternAllInButton = Pattern("all-in-button-720.png"):similar(0.4)
else
    patternAllInButton = Pattern("testAllIn.png"):similar(0.4)
end
patternPlayerChipNum0 = Pattern(chipNumPatternPrefix.."chip-num-0.png"):similar(0.75)
patternPlayerChipNum1 = Pattern(chipNumPatternPrefix.."chip-num-1.png"):similar(0.9)
patternPlayerChipNum2 = Pattern(chipNumPatternPrefix.."chip-num-2.png"):similar(0.7)
patternPlayerChipNum3 = Pattern(chipNumPatternPrefix.."chip-num-3.png"):similar(0.88)
patternPlayerChipNum4 = Pattern(chipNumPatternPrefix.."chip-num-4.png"):similar(0.8)
patternPlayerChipNum5 = Pattern(chipNumPatternPrefix.."chip-num-5.png"):similar(0.85)
patternPlayerChipNum6 = Pattern(chipNumPatternPrefix.."chip-num-6.png"):similar(0.7)
patternHandsBack = Pattern("hands-back.png"):similar(0.7)
patternWinNotice = Pattern("you-win-notice.png"):similar(0.3)


allInRangeTable = {}
allInHitTable = {}
call1RangeTable = {}
call1HitTable = {}
call2RangeTable = {}
call2HitTable = {}

playersExistsTable = { true, true, true, true }


patternGambleBar = Pattern("gambleBar.png"):similar(0.3)
patternQuickFindSeat = Pattern("quickFindSeat.png"):similar(0.5)
patternMainFindSeatButton = Pattern("mainFindSeat.png"):similar(0.7)
patternMainFindSeatButton2 = Pattern("mainFindSeat2.png"):similar(0.7)
disconnectGoToLoginBtn = Pattern("disconnectGoToLoginBtn.png"):similar(0.9)
patternInGameMenu = Pattern("aofInGameMenu.png"):similar(0.9)
patternQuitButtonInMenu = Pattern("aofInGameQuitbtn.png"):similar(0.5)
patternHomeAofTab = Pattern("homeTabAof.png"):similar(0.7)
patternHomeShortTab = Pattern("homeTabShort.png"):similar(0.7)
patternBuyInButton = Pattern("buy-in.png"):similar(0.7)---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by yd.
--- DateTime: 2019-07-01 16:24
---

debugMode = false
maxPlayHands = 0
thunderLog = false

imagePath = localPath.."printScreen/"
-- for thunder
thunderLogPath ="/mnt/shared/Pictures/"
-- for 逍遥
xiaoyaoLogPath ="/storage/emulated/0/Pictures/"
-- for blueStackCN
logPath="/sdcard/windows/BstSharedFolder/pkAuto/"
yunkongLogPath  = "/sdcard/"
function dialogStart(name)
    -- ==========  User Interface ===========
    dialogInit()
    addCheckBox("thunderLog", "雷电模拟器", false)
    addCheckBox("xiaoyaoLog", "逍遥模拟器", false)
    addCheckBox("yunkongLog", "云控", false)
    newRow()
    addTextView("名字id")
    addEditText("playerId", "默认")
    newRow()
    addCheckBox("noLogMode", "不打日志提高性能", false)
    addCheckBox("version2Mode", "启用2.0版本", false)
    newRow()
    addCheckBox("ppkShort", "ppk短牌", false)
    addCheckBox("aofDirect", "aof直接打", false)
    newRow()
    addCheckBox("avoidHeadsUp", "避免内部headsUp", false)
    newRow()
    addCheckBox("debugMode", "测试模式", false)
    newRow()
    addCheckBox("notClick", "不打牌只提示", false)
    newRow()
    addCheckBox("onlineMode", "网络模式", false)
    newRow()
    addTextView("-----------Settings-----------")
    newRow()
    addTextView("希望打的bb级别(仅yhpk生效)")
    addEditNumber("wantedBbSize", 0.5)
    newRow()
    addTextView("每轮执行最小最大分钟数")
    addEditNumber("playMinTimeInMin", 60)
    addEditNumber("playMaxTimeInMin", 90)
    newRow()
    addTextView("定点关闭，24小时制（0-23）>24为不生效")
    addEditNumber("shutDownHour", 25)
    newRow()
    addTextView("操作计数，超过自动停止，0不限制")
    addEditNumber("maxPlayHands", 0)
    newRow()
    addTextView("在线时长比例,每运行1小时休息时间")
    addEditNumber("sleepTimeCoef", 3)
    newRow()
    addTextView("-----------调试日志-----------")
    newRow()
    addCheckBox("checkTableSnap", "看牌截图", false)
    addCheckBox("checkHandsSnap", "出牌截图", false)
    addCheckBox("timeConsumeLog", "性能日志", false)
    newRow()
    addTextView("-----------DEBUG-----------")
    newRow()
    addCheckBox("debugSnap", "debug截图", false)
    addCheckBox("debugLogEnable", "debugLog", false)
    newRow()
    addCheckBox("stackDebugSnap", "debug筹码截图", false)
    newRow()
    dialogShowFullScreen(name)

    -- ==========  User Interface ===========
    --handsCnt = 0
    -- 避免测试模式在生产环境使用
    if debugMode then
        maxPlayHands = 100
        toast("测试模式", 10)
    end
    if thunderLog and not thunderLogDebug then
        logPath = thunderLogPath
    end

    if yunkongLog then
        logPath = yunkongLogPath
    end

    if xiaoyaoLog then
        logPath = xiaoyaoLogPath
    end
end
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wzx.
--- DateTime: 2019-06-12 18:52
---

function ppkCheckDisconnect()
    if exists(disconnectGoToLoginBtn) then
        errorLog("disconnect error, re-login")
        toast("disconnect error, re-login", 3)
        existsClick(disconnectGoToLoginBtn, 0)
        wait(5)
        existsClick(disconnectGoToLoginBtn, 0)
        wait(10)
        click(Location(520 , 1244))
        wait(10)
    end
end

function getOnTable(wantedBb)
    while exists(patternGambleBar) do
        existsClick(patternGambleBar, 0)
        wait(5)
    end

    local failCnt = 0
    local regionUp = Region(518,795,10,10)
    local regionDown = Region(518,1500,10,10)
    -- start

    while (not exists(patternMainFindSeatButton) and
            not exists(patternMainFindSeatButton2)) do
        existsClick(patternGambleBar, 0)
        wait(5)
    end

    while failCnt<4 do
        dragDrop(regionUp, regionDown)
        wait(5)

        existsClick(patternMainFindSeatButton, 2)
        existsClick(patternMainFindSeatButton2, 2)
        wait(3)

        if (exists(patternQuickFindSeat)) then
            existsClick(patternQuickFindSeat, 0)
            toast("finding seat", 3)
            wait(5)
            if not exists(patternQuickFindSeat) then
                toast("successfully found seat", 5)
                return true
            else
                wait(5)
                failCnt = failCnt +1
                click(Location(995 , 94))
                toast("fail finding seat, go refresh", 3)
                wait(5)
            end
        else
            if failCnt > 0 then
                return true
            else
                return false
            end
        end
    end
    return false
end

function exitTable()
    loopUntilClickAndDisappear(patternInGameMenu)
    wait(1)
    loopUntilClickAndDisappear(patternQuitButtonInMenu)
end
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wzx.
--- DateTime: 2019-06-12 18:52
---


function getOnTableAof(wantedBb)
    existsClick(patternHomeAofTab)
    wait(1)
    return getOnTable(wantedBb)
end

function getOnTableShort(wantedBb)
    existsClick(patternHomeShortTab)
    wait(1)
    return getOnTable(wantedBb)
end
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wzx.
--- DateTime: 2019-06-12 18:52
---


function shortMainLoop(endTime)
    toast("short mainloop start", 3)


    --loopUntilClickAndDisappear(patternBuyInButton)

    while(1) do
        existsClick(patternBuyInButton)
        if exists(checkButton, 0) then
            existsClick(checkButton, 0)
        else
            existsClick(foldButton, 0)
        end

        wait(4)

        if os.time() > endTime then
            LogFile("short endTime reach "..endTime)
            toast("short quit")
            --httpGet("https://maker.ifttt.com/trigger/autoBotTest/with/key/nfeLorbq9gn25evEb8mS_2N0QDwxcG6JUHMwShgM9w1?value1="..playerId.."_endTime_reach_"..endTime)
            return "endTime reach "..endTime
        end
    end
end

function updateTableAndBlind() end

function updateDealer() end---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by yd.
--- DateTime: 2019-06-13 09:24
---

bool_to_string={ [true]="true", [false]="false" }

function table.contains(table, element)
    for _, value in pairs(table) do
        if value == element then
            return true
        end
    end
    return false
end



function getCardNumChar(num)
    if num<10 then return string.format("%d",num) end
    if num==10 then return "t" end
    if num==11 then return "j" end
    if num==12 then return "q" end
    if num==13 then return "k" end
    if num==14 then return "a" end
    return "?"
end



function getCardTypeChar(type)
    if type =="hearts" then return "h" end
    if type =="diamonds" then return "d" end
    if type =="club" then return "c" end
    if type =="spade" then return "s" end
    return "?"
end


function stringSplit(inputstr, sep)
    if sep == nil then
        sep = "%s"
    end
    local t={}
    for str in string.gmatch(inputstr, "([^"..sep.."]+)") do
        table.insert(t, str)
    end
    return t
end


function tableContains(table, element)
    for _, value in pairs(table) do
        if value == element then
            return true
        end
    end
    return false
end

function ExistClickRandomGo(m)
    if (m)then click(Location(m:getX() + math.random(m:getW()) , m:getY() + math.random(m:getH()))) end
end



function deepCopyTable(inputTable)
    local output = {}
    for i, v in pairs(inputTable) do
        output[i] = v
    end
    return output
end
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by yd.
--- DateTime: 2019-07-01 16:24
---

debugMode = false
maxPlayHands = 0
thunderLog = false

imagePath = localPath.."printScreen/"
-- for thunder
thunderLogPath ="/mnt/shared/Pictures/"
-- for 逍遥
xiaoyaoLogPath ="/storage/emulated/0/Pictures/"
-- for blueStackCN
logPath="/sdcard/windows/BstSharedFolder/pkAuto/"
yunkongLogPath  = "/sdcard/"


thunderLog = true
notClick = true
onlineMode = true
noLogMode = true

function shortUserPasswordDialogStart()
    -- ==========  User Interface ===========
    dialogInit()
    addTextView("用户名")
    addEditText("userNameInput", ".....")
    newRow()
    addTextView("密码")
    addEditText("passwordInput", ".....")
    dialogShowFullScreen()

    logPath = thunderLogPath

end
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wzx.
--- DateTime: 2019-06-13 17:25
---
---
-- done
regionPlayerStatus = {}
regionPlayerStatus[1] = Region(566,67,92,51)
regionPlayerStatus[2] = Region(870,437,92,51)
regionPlayerStatus[3] = Region(870,1014,92,51)
regionPlayerStatus[5] = Region(123,1014,92,51)
regionPlayerStatus[6] = Region(123,437,92,51)

-- done
regionPlayerChipSlot = {}
regionPlayerChipSlot[1] = Region(460,100,166,166)
regionPlayerChipSlot[2] = Region(909,469,166,166)
regionPlayerChipSlot[3] = Region(909,1030,166,166)
regionPlayerChipSlot[5] = Region(16,1030,166,166)
regionPlayerChipSlot[6] = Region(16,469,166,166)

regionPlayerName = {}
--regionPlayerName[1] = Region(441,66,200,100)
--regionPlayerName[2] = Region(890,650,200,100)
--regionPlayerName[3] = Region(13,650,200,100)
--regionPlayerName[5] = Region(13,650,200,100)
--regionPlayerName[6] = Region(13,650,200,100)

-- done
regionDealerList = {}
regionDealerList[1] = Region(620,260,55,55)
regionDealerList[2] = Region(800,460,55,55)
regionDealerList[3] = Region(845,1193,55,55)
regionDealerList[4] = Region(620,1530,55,55)
regionDealerList[5] = Region(180,1193,55,55)
regionDealerList[6] = Region(220,460,55,55)

regionBlindSize = Region(540,1150,90,40)
regionAllInButton = Region(700,1500,200,200)
regionRaiseButton = Region(468,1444,155,155)

regionCard1num = Region(430,1692,53,50)
regionCard2num = Region(545,1692,53,50)

regionCard1type = Region(452,1785,90,80)
regionCard2type = Region(567,1785,90,80)

regionFoldButton = Region(246,1546,50,50)
regionSmallAllInButton = Region(776,1540,55,55)
regionFoldButtonRedPart = Region(285,1540,10,10)
flopCardWhitePart = Region(324,961,10,10)
regionCallButtonGreenPart = Region(815,1540,10,10)

raiseButton = Region(538,1499,10,10)
allInEndPoint = Region(538,696,10,10)

-- 筹码中线位置, y轴为顶部
locationStack4Players = {}
locationStack4Players[1] = Location(540,263)
locationStack4Players[2] = Location(985,854)
locationStack4Players[3] = Location(540,1603)
locationStack4Players[4] = Location(98,854)

stack4PlayersFindDotWeight = 70
stack4PlayersFindDotHeight = 46
stack4PlayersFindDotXShift = -27
stack4PlayersFindDotYShift = 0

stackInterval = 22
stackShiftWithOutDotX = -4
stackShiftWithDotX = -4
stackShiftWithOutDotY = 5
stackShiftWithDotY = 5
stackShiftHeroCoef = 1.33

stackNumHeight = 44
stackNumWidth = 30

extraStackNum = 0
heroStackCoef = 1
--local regionToFindPlayerDot = Region(region:offset(-7,0), 46, 50)

--stackNumInterval = 22
--stackNumWidth = 22
--stackNumHeight = 22
--stackNumShiftX = 1
--stackNumShiftY = 1

--local regionToFindPlayerDot = Region(region:offset(-7,0), 46, 50)
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wangzixiao.
--- DateTime: 2020/2/20 下午4:46
---
function checkShortHandAndTable(getTable, newPlayerChips, newTablePlayerPreciseChips, bbSize, newDealerPosition, playersExists)
    local type1,type2,num1,num2,handsType,cardInfo =
    getHandsWithRegions(regionCard1type, regionCard2type, regionCard1num, regionCard2num)
    local playersStatus, exists = getPlayerStatus(playersExists, regionPlayerStatus, regionPlayerChipSlot, 6, 4)

    local dealerPosition = -1
    if getTable then
        dealerPosition = newDealerPosition
    else
        dealerPosition = getDealerPos(regionDealerList)
    end


    local playerChips = {}
    local tablePlayerPreciseChips = {}
    --if getTable then
    --    playerChips = newPlayerChips
    --    tablePlayerPreciseChips = newTablePlayerPreciseChips
    --else
    --    playerChips,tablePlayerPreciseChips = getPlayerChipV2(bbSize, playersExistsTable)
    --end

    return type1,type2,num1,num2,handsType,cardInfo,dealerPosition,playersStatus,exists,playerChips,tablePlayerPreciseChips
end
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wzx.
--- DateTime: 2019-06-12 18:52
---


--function getDealerPos(regionDealers)
--    local dealerPos = -1
--    for i, r in ipairs(regionDealers) do
--        if r:exists(dealerPattern,0) then
--            dealerPos = i
--            return dealerPos
--        end
--    end
--    return dealerPos
--end

--function getHandsWithRegions(regionCard1type, regionCard2type, regionCard1num, regionCard2num)
--    local num2Prefix = ""
--    local type2Prefix = ""
--    if platform == "yhpk" then
--        num2Prefix = "r-"
--        type2Prefix = "r-"
--    end
--
--    local type1 = getCardType(regionCard1type)
--    local type2 = getCardTypeRight(regionCard2type)
--
--    local num1 = getCardNum(regionCard1num, type1, "")
--    local num2 = getCardNum(regionCard2num, type2, num2Prefix)
--
--
--    local handsType = getHandsType(type1, type2, num1, num2)
--    local cardInfo = getCardNumChar(num1)..getCardNumChar(num2)
--            ..getCardTypeChar(type1)..getCardTypeChar(type2)
--    return type1,type2,num1,num2,handsType,cardInfo
--end


---- todo: change to short
--function checkShortHandAndTable(getTable, newPlayerChips, newTablePlayerPreciseChips, bbSize, newDealerPosition, playersExists)
--    local type1,type2,num1,num2,handsType,cardInfo =
--    getHandsWithRegions(regionCard1type, regionCard2type, regionCard1num, regionCard2num)
--    local playersStatus, exists = getPlayerStatus(playersExists, regionPlayerStatus, regionPlayerChipSlot)
--
--    local dealerPosition = -1
--    if getTable then
--        dealerPosition = newDealerPosition
--    else
--        dealerPosition = getDealerPos(regionDealerList)
--    end
--
--
--    local playerChips = {}
--    local tablePlayerPreciseChips = {}
--    if getTable then
--        playerChips = newPlayerChips
--        tablePlayerPreciseChips = newTablePlayerPreciseChips
--    else
--        playerChips,tablePlayerPreciseChips = getPlayerChipV2(bbSize, playersExistsTable)
--    end
--
--    return type1,type2,num1,num2,handsType,cardInfo,dealerPosition,playersStatus,exists,playerChips,tablePlayerPreciseChips
--end


function ppkShortMainLoop(endTime)
    local currentDealerPosition = -1
    local bbSize = -1
    local tick = 0
    local getTable = false
    local sendTableLog = false
    local newTable = true
    local takeAction = false
    local currentPlayerChips = { 1, 1, 1, 1}
    local currentPlayerPreciseChips = { 8, 8, 8, 8}
    --local playersExistsTable
    local handsCnt = 0
    local handsCntPrecise = 0
    local lastRoundTime = os.time()
    local headsUpCount = 0
    local getOntableNum = 0
    local friendsExist = false
    toast("mainloop start", 3)


    isFirstRound = true
    playersStatusFirstRound = {}
    playersStatusFirstRoundOrigin = {}
    heroAction = ""
    while(1) do
        -- dealer 消失， 先看bb size
        if newTable or debugMode then
            local newBbSize = getBlindSize(regionBlindSize, tick, bbSize)
            if newBbSize ~= nil and newBbSize ~= -1 then
                bbSize = newBbSize
                newTable = false
            end
            playersExistsTable = { true, true, true, true }
        end

        -- dealer位置变了, new round
        -- 无人上桌dealer也会消失
        if (currentDealerPosition == -1 or not regionDealerList[currentDealerPosition]:exists(dealerPattern, 0) or debugMode) then
            local newDealerPosition = getDealerPos(regionDealerList)

            --if handsCntPrecise%10 == 0 then
            --    friendsExist = checkFriendsExist()
            --end

            isFirstRound = true
            playersStatusFirstRound = {}
            heroAction = ""


            LogFile("newDealerPosition: "..newDealerPosition)

            if newDealerPosition ~= -1 then
                currentDealerPosition = newDealerPosition

                --currentPlayerChips, currentPlayerPreciseChips = getPlayerChipV2(bbSize, playersExistsTable)
                getTable = true
                sendTableLog = false
                takeAction = false
                handsCntPrecise = handsCntPrecise+1
            else
                -- dealer 消失， 先看bb size
                newTable = true
                getTable = false
            end

            --if debugMode then
            --    currentPlayerChips, currentPlayerPreciseChips = getPlayerChipV2(bbSize, playersExistsTable)
            --end




            local playerNum = 0
            for i, v in pairs(playersExistsTable) do
                if v then
                    playerNum = playerNum+1
                end
            end

            if playerNum == 2 then
                headsUpCount = headsUpCount + 1
            else
                headsUpCount = 0
            end


            --if debugMode then
            --    local type1,type2,num1,num2,handsType,cardInfo,dealerPosition,playersStatus,exists,playerChips,tablePlayerPreciseChips =
            --    checkShortHandAndTable(getTable, currentPlayerChips, currentPlayerPreciseChips, bbSize, currentDealerPosition, playersExistsTable)
            --    debugLog(" players: "..table.concat(playersStatus)..", dealerPos: "..newDealerPosition.. ", playerNum: "..playerNum)
            --end


        end

        if getTable then
            -- 牌上手之后操作
            local rangeQuery = ""
            local doThing = ""
            local r, g, b = getColor(regionFoldButtonRedPart, 0)
            --debugLog(string.format("rgb: %d %d %d", r,g,b))
            -- 出现红色按钮
            if r > 222 and b < 100 then
                --r egionAllInButton:highlight(3)
                wait(0.3)
                local type1,type2,num1,num2,handsType,cardInfo,dealerPosition,playersStatus,exists,playerChips,tablePlayerPreciseChips =
                checkShortHandAndTable(getTable, currentPlayerChips, currentPlayerPreciseChips, bbSize, currentDealerPosition, playersExistsTable)

                playersExistsTable = exists

                -- 状态变化，说明后位有动作，需要额外操作
                local preflopMoreAction = false
                for i, v in ipairs(playersStatusFirstRoundOrigin) do
                    if v ~= playersStatus[i] then
                        preflopMoreAction = true
                    end
                end

                local isPostFlop = false
                local flopCardR, flopCardG, flopCardB = getColor(flopCardWhitePart, 0)
                if flopCardR+flopCardG+flopCardB>550 then
                    isPostFlop = true
                end

                if not isPostFlop and (isFirstRound or (preflopMoreAction))  then
                    local rangeList
                    doThing,rangeQuery, rangeList = getShortActionV1(playersStatus, dealerPosition, playerChips, nil, handsType)
                    local allinR, allinG, allinB = getColor(regionCallButtonGreenPart, 0)
                    debugLog("rangeList "..table.concat(rangeList, " "))
                    if not notClick then
                        debugLog("allinG "..allinG)
                        if allinG > 180 then
                            ExistClickRandomGo(regionSmallAllInButton)
                        else
                            if doThing == "a" then
                                dragDrop(raiseButton, allInEndPoint)
                            elseif doThing == "c" or doThing == "r" then
                                ExistClickRandomGo(regionSmallAllInButton)
                            else
                                ExistClickRandomGo(regionFoldButton)
                            end
                        end
                    else
                        if allinG > 180 then
                            doThing = "c"
                        end

                        if (rangeList[1] ~= nil and rangeList[1]>0.25) and (rangeList[2] ~= nil and rangeList[2]>0.25) then
                            toast(string.format("allIn: %f.2, call: %f.2"), rangeList[1],rangeList[2])
                        else
                            toast(doThing, 7)
                        end
                    end

                    if checkHandsSnap or tableRange == 1 then
                        Snapshot(cardInfo.."r".."_doThing_"..doThing
                                .."_playerPreciseChips_"..table.concat(tablePlayerPreciseChips, "_")
                                .."_dealer"..dealerPosition
                                .."_status_"..table.concat(playersStatus)
                                .."_rangeQuery_"..rangeQuery)
                    end
                end




                -- logging --
                local fullInfo = "card: "..cardInfo..", do: ".. doThing
                        ..", playerChips: "..table.concat(playerChips)
                        ..", playerPreciseChips: "..table.concat(tablePlayerPreciseChips, " ")
                        ..", players: "..table.concat(playersStatus)
                        ..", dealerPos: "..dealerPosition
                        ..", getHands: "..bool_to_string[getTable]
                        ..", playersExistsTable "..bool_to_string[playersExistsTable[1]]..bool_to_string[playersExistsTable[2]]..bool_to_string[playersExistsTable[4]]
                        ..", handsType:"..handsType
                        ..", isFirstRound: "..bool_to_string[isFirstRound]
                        ..", rangeQuery: "..rangeQuery

                heroAction = doThing

                LogFile(fullInfo);
                lastRoundTime = os.time()
                if debugLogEnable then
                    --toast(fullInfo,3)
                end
                --if range > tableRange and doThing == "a" then
                --    errorLog("range loose than standard"..fullInfo)
                --elseif range < tableRange and doThing == "f" then
                --    errorLog("range tight than standard"..fullInfo)
                --end
                --if timeConsumeLog then
                --    LogFile("Time: "
                --            .."， Card: "..string.format("%.3f",timeGetCard-timeStart)
                --            ..", Dealer: "..string.format("%.3f",timeGetDealer-timeGetCard)
                --            ..", Player: "..string.format("%.3f",timeGetPlayer-timeGetDealer)
                --            ..", Strategy: "..string.format("%.3f",timeStrategy-timeGetPlayer)
                --            ..", Total: "..string.format("%.3f",timeStrategy-timeStart))
                --end

                --getTable = false
                takeAction = true
                handsCnt = handsCnt+1
                isFirstRound = false
                --toast(handsCnt)
            end

        end


        wait(0.3)

        tick = tick+1



        -- - --- do log ---------
        if (getTable and not sendTableLog) or debugMode then
            if checkTableSnap then
                Snapshot("table_"..os.date("%b%d%H%M%S").."_".. currentPlayerPreciseChips[1].."_".. currentPlayerPreciseChips[2].."_"
                        .. currentPlayerPreciseChips[3].."_".. currentPlayerPreciseChips[4])
            end
            if autoHandTestMode then
                LogFile(table.concat(currentPlayerChips))
            else
                --LogFile("hands playerChips: "..table.concat(currentPlayerChips, " ")
                --        .." playerPreciseChips: "..table.concat(currentPlayerPreciseChips, " ")
                --        ..", dealer: ".. currentDealerPosition
                --        ..", BB: "..bbSize)
            end
            sendTableLog = true
        end


        --if avoidHeadsUp and headsUpCount >= 20 then
        --    local nextRoundWaitTimeMinute = 15
        --    LogFile("headsUpCount reach limit 20")
        --    return "headsUpCount reach limit 20", handsCntPrecise, nextRoundWaitTimeMinute
        --end

        --if friendsExist then
        --    LogFile("friendsExist quit")
        --    return "friendsExist quit", handsCntPrecise, nextRoundWaitTimeMinute
        --end


        if not prodEnv then
            if os.time() > endTime then
                LogFile("endTime reach "..endTime)
                --httpGet("https://maker.ifttt.com/trigger/autoBotTest/with/key/nfeLorbq9gn25evEb8mS_2N0QDwxcG6JUHMwShgM9w1?value1="..playerId.."_endTime_reach_"..endTime)
                return "endTime reach "..endTime,handsCntPrecise
            end

            -- 上桌检测
            if os.time() > (lastRoundTime+100) then
                existsClick(chipSlotImg, 0)
                getOntableNum = getOntableNum+1
                if getOntableNum >= 3 then
                    return "不能上桌",handsCntPrecise,120
                end
            end

            if os.time() > (lastRoundTime+600) then
                LogFile("10分钟 不打自动换桌")
                --httpGet("https://maker.ifttt.com/trigger/autoBotTest/with/key/nfeLorbq9gn25evEb8mS_2N0QDwxcG6JUHMwShgM9w1?value1="..playerId.."_endTime_reach_"..endTime)
                return "10分钟 不打自动换桌",handsCntPrecise
            end

            if maxPlayHands ~= 0 and handsCntPrecise > maxPlayHands then
                return "maxHands reach "..maxPlayHands,handsCntPrecise
            end

            if os.date("%H")==string.format("%d", shutDownHour)then
                return "endTimeReach "..shutDownHour,handsCntPrecise
            end
        end
    end
end

function updateTableAndBlind() end

function updateDealer() end---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wzx.
--- DateTime: 2019-06-13 17:25
---
platform = "ppk"
gameType = "aof"

today = os.date("_%b_%d")
timeLog = 1
setHighlightStyle(0x8fffff00, true)
logCount = 0
logTempTable = {}
logBatch = 50

directPlay = true

heroStackImagePrefix = ""
rightCardNumPrefix = ""
rightCardTypePrefix = ""

stackSimilarity = 0.75

checkButton = Pattern("check-button.png"):similar(0.7)
foldButton = Pattern("fold-button.png"):similar(0.7)
allinNotice = Pattern("all-in-notice.png"):similar(0.7)
foldNotice = Pattern("fold-notice.png"):similar(0.7)
waitingNotice = Pattern("waiting-notice.png"):similar(0.6)
chipSlotImg = Pattern("emptyPlayer.png"):similar(0.85)
dealerPattern = Pattern("dealer.png"):similar(0.5)

patternHeartsRight = Pattern("hearts.png"):similar(0.9)
patternDiamondsRight = Pattern("diamonds.png"):similar(0.95)
patternSpadeRight = Pattern("spade.png"):similar(0.95)
patternClubRight = Pattern("club.png"):similar(0.95)
patternHearts = Pattern("hearts.png"):similar(0.9)
patternDiamonds = Pattern("diamonds.png"):similar(0.95)
patternSpade = Pattern("spade.png"):similar(0.95)
patternClub = Pattern("club.png"):similar(0.95)

patternBbSize0_5 = Pattern("bb-size-0-5.png"):similar(0.8)
patternBbSize1 = Pattern("bb-size-1.png"):similar(0.9)
patternBbSize4 = Pattern("bb-size-4.png"):similar(0.9)
patternBbSize10 = Pattern("bb-size-10.png"):similar(0.8)
patternBbSize50 = Pattern("bb-size-50.png"):similar(0.8)
patternBbSize200 = Pattern("bb-size-200.png"):similar(0.8)
patternPlayerChipDot = Pattern("chip-dot.png"):similar(0.9)
patternPlayerChipDot2 = Pattern("chip-dot2.png"):similar(0.9)

chipNumPatternPrefix = ""
if thunderLog or yunkongLog then
    chipNumPatternPrefix = "leidian-"
end

if yunkongLog then
    patternAllInButton = Pattern("all-in-button-720.png"):similar(0.4)
else
    patternAllInButton = Pattern("testAllIn.png"):similar(0.4)
end
patternPlayerChipNum0 = Pattern(chipNumPatternPrefix.."chip-num-0.png"):similar(0.75)
patternPlayerChipNum1 = Pattern(chipNumPatternPrefix.."chip-num-1.png"):similar(0.9)
patternPlayerChipNum2 = Pattern(chipNumPatternPrefix.."chip-num-2.png"):similar(0.7)
patternPlayerChipNum3 = Pattern(chipNumPatternPrefix.."chip-num-3.png"):similar(0.88)
patternPlayerChipNum4 = Pattern(chipNumPatternPrefix.."chip-num-4.png"):similar(0.8)
patternPlayerChipNum5 = Pattern(chipNumPatternPrefix.."chip-num-5.png"):similar(0.85)
patternPlayerChipNum6 = Pattern(chipNumPatternPrefix.."chip-num-6.png"):similar(0.7)
patternHandsBack = Pattern("hands-back.png"):similar(0.7)
patternWinNotice = Pattern("you-win-notice.png"):similar(0.3)


allInRangeTable = {}
allInHitTable = {}
call1RangeTable = {}
call1HitTable = {}
call2RangeTable = {}
call2HitTable = {}

playersExistsTable = { true, true, true, true , true, true}
printConsole = false

patternGambleBar = Pattern("gambleBar.png"):similar(0.3)
patternQuickFindSeat = Pattern("quickFindSeat.png"):similar(0.5)
patternMainFindSeatButton = Pattern("mainFindSeat.png"):similar(0.7)
patternMainFindSeatButton2 = Pattern("mainFindSeat2.png"):similar(0.7)
disconnectGoToLoginBtn = Pattern("disconnectGoToLoginBtn.png"):similar(0.9)
patternInGameMenu = Pattern("aofInGameMenu.png"):similar(0.9)
patternQuitButtonInMenu = Pattern("aofInGameQuitbtn.png"):similar(0.5)
patternHomeAofTab = Pattern("homeTabAof.png"):similar(0.7)
patternHomeShortTab = Pattern("homeTabShort.png"):similar(0.7)
patternBuyInButton = Pattern("buy-in.png"):similar(0.7)---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wzx.
--- DateTime: 2019-06-13 09:26
---

function shortInitV1(strategyTable, hitTable, handRangeTable, tableRangeTable)
    for rangeNum,cardsInfoTable in pairs(strategyTable) do
        for index,cardInfo in pairs(cardsInfoTable) do
            if handRangeTable[cardInfo]==nil then
                handRangeTable[cardInfo] = rangeNum
            end
        end
    end

    for rangeNum, tableInfoTable in pairs(hitTable) do
        for index, tableInfo in pairs(tableInfoTable) do
            setTable0To1Or2(tableInfo, rangeNum, tableRangeTable)
        end
    end
end


function getThisRoundStatus(playersStatus, hPos)
    local newStatus = {}
    for i = 1, 5 do
        local pivot = hPos+i
        if hPos+i > 6 then
            pivot = pivot-6
        end
        if playersStatus[pivot] ~= "n" and playersStatus[pivot] ~= "e" then
            table.insert(newStatus, playersStatus[pivot])
        end
    end
    return newStatus
end

function getShortActionV1(playersStatus, dealerPos, playerStacks, _, hands)
    --local originalHPos = 3
    local onTablePlayersStatus, onTablePlayersStack, actualDealerPos, playerNum = getOnTablePlayer(playersStatus, dealerPos, playerStacks, 4)
    debugLog(string.format("onTablePlayersStatus %s actualDealerPos %s playerNum %d", table.concat(onTablePlayersStatus), actualDealerPos, playerNum))
    local initPosToDealer = 1
    --if playerNum >= 4 then
    --    initPosToDealer = 3
    --elseif playerNum <= 3 then
    --    initPosToDealer = 0
    --end


    local statusWithActionOrder, stackWithActionOrder, hStatus, blindTableWithActionOrder
        = getPlayerStatusAndStackWithActionOrder(onTablePlayersStatus, actualDealerPos, onTablePlayersStack, playerNum, initPosToDealer)
    if not isFirstRound then
        statusWithActionOrder = getThisRoundStatus(onTablePlayersStatus, 4)
    end

    debugLog(string.format("statusWithActionOrder %s actualDealerPos %s firstRound %s"
        , table.concat(statusWithActionOrder), actualDealerPos, bool_to_string[isFirstRound]))
    local rangeThis, rangeFirst, rangeQuery = getShortV1Range(statusWithActionOrder, playersStatusFirstRound, heroAction, isFirstRound, playerNum, hands)
    local action

    local newRange = {}
    if rangeThis ~= nil and rangeThis[1] >= 0  then
        -- 把绝对概率改为条件概率
        if isFirstRound then
            newRange = rangeThis
            debugLog("rangeThis "..table.concat(rangeThis, " "))
        else
            debugLog("rangeFirst "..table.concat(rangeFirst, " "))
            debugLog("rangeThis "..table.concat(rangeThis, " "))
            newRange[1] = rangeThis[1]/rangeFirst[1]
            newRange[2] = rangeThis[2]/rangeFirst[2]
            newRange[3] = rangeThis[3]/rangeFirst[3]
        end
        -- 取值
        if isFirstRound then
            local a = math.random()
            local b = math.random()
            if a <= newRange[1] then
                action = "a"
            elseif b <= newRange[2] then
                action = "c"
            else
                action = "f"
            end
            debugLog(a.." "..b)
        else
            if math.random() <= newRange[1] then
                action = "a"
            else
                action = "f"
            end
        end
    else
        action = "f"
    end
    
    if rangeThis ~= nil and rangeThis[1] < 0 then
        action = "rangeNotFind"
    end

    if isFirstRound then
        playersStatusFirstRound = statusWithActionOrder
        playersStatusFirstRoundOrigin = playersStatus
        heroAction = action
    end


    return action, rangeQuery, newRange
end


function getActionTable(query, hands)
    if onlineMode then
        local params = {}
        params["query"] = md5.sumhexaAddSalt(query)
        params["hands"] = md5.sumhexaAddSalt(hands)
        params["password"] = md5.sumhexaAddSalt("")
        params["userName"] = md5.sumhexaAddSalt("")
        local req = "http://39.99.229.18/"
        local res = httpPost(req, params)
        local num
        debugLog("online req: "..req..". res："..res)
        local resLen = string.len(res)
        res = string.sub(res, 2,resLen-1)
        local resListStr =  stringSplit(res, ",")

        if string.match(res , "-") ~= nil then
            -- res = [-333][-1][-2] 都是有错误
            return {-1}
        elseif string.match(res , ",") == nil then
            -- res = [] => fold
            return nil
        else
            local resListNum = {}
            for i, v in ipairs(resListStr) do
                resListNum[i] = tonumber(v)
            end
            return resListNum
        end
    else
        if shortActionV1Table[query] == nil then
            return {-1}
        else
            return shortActionV1Table[query][hands]
        end
    end
end

function getShortV1Range(playersStatusThisRound, playersStatusFirstRound, heroAction, isFirstRound, playerNum, hands)
    local query = ""

    local encodedThisRound = {}
    local raiseExist = false
    local allInCount = 0
    for i, v in ipairs(playersStatusThisRound) do
        if v == "a" then
            raiseExist = true
        end

        if raiseExist and v == "c" or v == "a" then
            encodedThisRound[i] = "a"
            allInCount = allInCount+1
        else
            encodedThisRound[i] = v
        end
    end
    if playerNum == 5 or playerNum == 3 then
        -- range第一位补充F 当成6人
        table.insert(encodedThisRound, 1, "f")
    end


    if not isFirstRound then
        local encodedFirstRound = {}
        for i, v in ipairs(playersStatusFirstRound) do
            encodedFirstRound[i] = v
        end
        if playerNum == 5 or playerNum == 3 then
            -- 5人 range第一位补充F 当成6人
            -- 3人 range第一位补充F 当成4人
            table.insert(encodedThisRound, 1, "f")
        end

        if allInCount >= 2 then
            query = "overcall"
        else
            query = table.concat(encodedFirstRound).."_"..heroAction.."_"..table.concat(encodedThisRound)
        end
        debugLog(string.format("range %s", query))
        return getActionTable(query, hands), getActionTable(table.concat(encodedFirstRound),hands), query
    else
        if allInCount >= 2 then
            query = "overcall"
        else
            query = table.concat(encodedThisRound)
        end

        debugLog(string.format("range %s", query))
        return getActionTable(query, hands), nil, query
    end
end


shortActionV1Table = {}




-- 构建翻前搜索是第一轮状态 + 第二轮状态
-- huuuuu 选择 a => huuuuu_a
-- 后位行动 caffah
-- 组合为 huuuuu_a_caffah
function buildShortV1Query(status1, action, status2)
    local query = table.concat(status1).."_"..action.."_"..table.concat(status2)
end

-- 读取 A8s:1.0,A9s:1.0,ATs:1.0,ATo:0.13,AJs:1.0,AJo:0.592,AQs:1.0,AQo:1.0,AKs:0.192,AKo:1.0,
-- 转化为Table: {A8s: 1.0, A9s: 1.0}
-- 所有值概率是总概率，如果需要条件概率，需要 huuu_c_aaa[1] / huuu_c[1] = huuu_c_aaa[1] / huuu[2]
function formatShortV1HandsRangeData(dataStr)
    local res = {}
    dataStr = string.lower(dataStr)
    -- 分隔符
    local tmpDataPairSplit = stringSplit(dataStr, ",")
    for _, handsDataPair in ipairs(tmpDataPairSplit) do
        local tmp = stringSplit(handsDataPair, ":")
        res[tmp[1]] = tonumber(tmp[2])
    end
    return res
end

--player act	status 2nd rnd
--utg play	huuuuu	a		A8s:1.0,A9s:1.0,ATs:1.0,ATo:0.13,AJs:1.0,AJo:0.592,AQs:1.0,AQo:1.0,AKs:0.192,AKo:1.0,T9s:0.806,TT:0.678,JTs:1.0,JTo:0.624,QTs:1.0,KTs:1.0,JJ:0.816,QJs:1.0,KJs:1.0,QQ:0.592,KQs:1.0,KQo:1.0,KK:0.528
--huuuuu	c		AA:1.0,A6s:0.216,A7s:1.0,A9o:0.272,ATo:0.87,AJo:0.408,AKs:0.808,98s:1.0,T8s:1.0,99:0.57,T9s:0.194,T9o:0.036,J9s:0.536,TT:0.322,JTo:0.376,QTo:0.524,KTo:0.212,JJ:0.184,QJo:0.806,KJo:0.886,QQ:0.408,KK:0.472
--huuuuu	c	acfff	AA:1.0,ATo:0.688,AJo:0.408,AKs:0.808,TT:0.322,JJ:0.184,QQ:0.408,KK:0.472

-- 生成结果 {query: handsTable}
-- handsTable[1]: p(a) handsTable[2]: p（c） handsTable[3]: p（f）
function formatShortV1PreflopData(dataFileName, short)
    local file = io.open(localPath..dataFileName, "r")
    if (file == nil) then
        return false
    end


    -- 胜率 负率 平率
    for line in file:lines() do
        if line ~= nil then
            -- "%s" stands for whitespace in lua
            line = string.lower(line)
            -- 分隔符

            local tmpFileSplit = stringSplit(line, "%s")

            local query2 = ""
            local query1 = ""
            local act1 = ""

            if tmpFileSplit[2] ~= nil and tmpFileSplit[3] ~= nil then
                query1 = tmpFileSplit[2]
                act1 = tmpFileSplit[3]

                if act1 == "a" or string.sub(act1,1,1) == "r" or act1 == "ca" then
                    act1 = "a"
                end

                local rangeData = tmpFileSplit[5]

                --print("4: "..tmpFileSplit[4])
                if tmpFileSplit[4] == "n"  then
                    -- 有效输入:第一轮行动表
                    -- 更新表
                    local action = tmpFileSplit[3]

                    local rangePairMap = formatShortV1HandsRangeData(rangeData)
                    if shortActionV1Table[query1] == nil then
                        shortActionV1Table[query1] = {}
                    end
                    for hands, value in pairs(rangePairMap) do
                        if shortActionV1Table[query1][hands] == nil then
                            shortActionV1Table[query1][hands] = {0,0,0}
                        end

                        if action == "a" or string.sub(action,1,1) == "r" or action == "ca" then
                            shortActionV1Table[query1][hands][1] = shortActionV1Table[query1][hands][1] + value
                        elseif action == "c" then
                            shortActionV1Table[query1][hands][2] = shortActionV1Table[query1][hands][2] + value
                        end

                        if shortActionV1Table[query1][hands][1] + shortActionV1Table[query1][hands][2] > 1.05 then
                            errorLog(string.format("data err: %s_%s, a: %f, c: %f",query1,hands,shortActionV1Table[query1][hands][1],shortActionV1Table[query1][hands][2]))
                        end
                    end
                else
                    --debugLog(line)
                    -- 有效输入：第二轮行动表
                    -- 更新表
                    -- 第二轮意味着有人raise， 因此返回的act都是raise
                    query2 = tmpFileSplit[4]
                    local query = query1.."_"..act1.."_"..query2
                    local rangePairMap = formatShortV1HandsRangeData(rangeData)

                    --print("query "..query)
                    shortActionV1Table[query] = {}
                    for hands, value in pairs(rangePairMap) do
                        shortActionV1Table[query][hands] = {value,0,1-value}
                    end
                end
            end
        end
    end

    for query, QueryHandsData in pairs(shortActionV1Table) do
        for _, handsData in pairs(QueryHandsData) do
            handsData[3] = 1-handsData[1]-handsData[2]
            if handsData[3] < 0.001 then
                handsData[3] = 0
            end
        end
    end

    io.close(file)
    return true
end
md5 = {
  _VERSION     = "md5.lua 1.1.0",
  _DESCRIPTION = "MD5 computation in Lua (5.1-3, LuaJIT)",
  _URL         = "https://github.com/kikito/md5.lua",
  _LICENSE     = [[
    MIT LICENSE

    Copyright (c) 2013 Enrique García Cota + Adam Baldwin + hanzao + Equi 4 Software

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  ]]
}

-- bit lib implementions

local char, byte, format, rep, sub =
  string.char, string.byte, string.format, string.rep, string.sub
local bit_or, bit_and, bit_not, bit_xor, bit_rshift, bit_lshift

local ok, bit = pcall(require, 'bit')
if ok then
  bit_or, bit_and, bit_not, bit_xor, bit_rshift, bit_lshift = bit.bor, bit.band, bit.bnot, bit.bxor, bit.rshift, bit.lshift
else
  ok, bit = pcall(require, 'bit32')

  if ok then

    bit_not = bit.bnot

    local tobit = function(n)
      return n <= 0x7fffffff and n or -(bit_not(n) + 1)
    end

    local normalize = function(f)
      return function(a,b) return tobit(f(tobit(a), tobit(b))) end
    end

    bit_or, bit_and, bit_xor = normalize(bit.bor), normalize(bit.band), normalize(bit.bxor)
    bit_rshift, bit_lshift = normalize(bit.rshift), normalize(bit.lshift)

  else

    local function tbl2number(tbl)
      local result = 0
      local power = 1
      for i = 1, #tbl do
        result = result + tbl[i] * power
        power = power * 2
      end
      return result
    end

    local function expand(t1, t2)
      local big, small = t1, t2
      if(#big < #small) then
        big, small = small, big
      end
      -- expand small
      for i = #small + 1, #big do
        small[i] = 0
      end
    end

    local to_bits -- needs to be declared before bit_not

    bit_not = function(n)
      local tbl = to_bits(n)
      local size = math.max(#tbl, 32)
      for i = 1, size do
        if(tbl[i] == 1) then
          tbl[i] = 0
        else
          tbl[i] = 1
        end
      end
      return tbl2number(tbl)
    end

    -- defined as local above
    to_bits = function (n)
      if(n < 0) then
        -- negative
        return to_bits(bit_not(math.abs(n)) + 1)
      end
      -- to bits table
      local tbl = {}
      local cnt = 1
      local last
      while n > 0 do
        last      = n % 2
        tbl[cnt]  = last
        n         = (n-last)/2
        cnt       = cnt + 1
      end

      return tbl
    end

    bit_or = function(m, n)
      local tbl_m = to_bits(m)
      local tbl_n = to_bits(n)
      expand(tbl_m, tbl_n)

      local tbl = {}
      for i = 1, #tbl_m do
        if(tbl_m[i]== 0 and tbl_n[i] == 0) then
          tbl[i] = 0
        else
          tbl[i] = 1
        end
      end

      return tbl2number(tbl)
    end

    bit_and = function(m, n)
      local tbl_m = to_bits(m)
      local tbl_n = to_bits(n)
      expand(tbl_m, tbl_n)

      local tbl = {}
      for i = 1, #tbl_m do
        if(tbl_m[i]== 0 or tbl_n[i] == 0) then
          tbl[i] = 0
        else
          tbl[i] = 1
        end
      end

      return tbl2number(tbl)
    end

    bit_xor = function(m, n)
      local tbl_m = to_bits(m)
      local tbl_n = to_bits(n)
      expand(tbl_m, tbl_n)

      local tbl = {}
      for i = 1, #tbl_m do
        if(tbl_m[i] ~= tbl_n[i]) then
          tbl[i] = 1
        else
          tbl[i] = 0
        end
      end

      return tbl2number(tbl)
    end

    bit_rshift = function(n, bits)
      local high_bit = 0
      if(n < 0) then
        -- negative
        n = bit_not(math.abs(n)) + 1
        high_bit = 0x80000000
      end

      local floor = math.floor

      for i=1, bits do
        n = n/2
        n = bit_or(floor(n), high_bit)
      end
      return floor(n)
    end

    bit_lshift = function(n, bits)
      if(n < 0) then
        -- negative
        n = bit_not(math.abs(n)) + 1
      end

      for i=1, bits do
        n = n*2
      end
      return bit_and(n, 0xFFFFFFFF)
    end
  end
end

-- convert little-endian 32-bit int to a 4-char string
local function lei2str(i)
  local f=function (s) return char( bit_and( bit_rshift(i, s), 255)) end
  return f(0)..f(8)..f(16)..f(24)
end

-- convert raw string to big-endian int
local function str2bei(s)
  local v=0
  for i=1, #s do
    v = v * 256 + byte(s, i)
  end
  return v
end

-- convert raw string to little-endian int
local function str2lei(s)
  local v=0
  for i = #s,1,-1 do
    v = v*256 + byte(s, i)
  end
  return v
end

-- cut up a string in little-endian ints of given size
local function cut_le_str(s,...)
  local o, r = 1, {}
  local args = {...}
  for i=1, #args do
    table.insert(r, str2lei(sub(s, o, o + args[i] - 1)))
    o = o + args[i]
  end
  return r
end

local swap = function (w) return str2bei(lei2str(w)) end

-- An MD5 mplementation in Lua, requires bitlib (hacked to use LuaBit from above, ugh)
-- 10/02/2001 jcw@equi4.com

local CONSTS = {
  0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
  0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
  0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
  0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
  0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
  0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
  0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
  0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
  0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
  0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
  0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
  0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
  0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
  0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
  0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
  0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391,
  0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476
}

local f=function (x,y,z) return bit_or(bit_and(x,y),bit_and(-x-1,z)) end
local g=function (x,y,z) return bit_or(bit_and(x,z),bit_and(y,-z-1)) end
local h=function (x,y,z) return bit_xor(x,bit_xor(y,z)) end
local i=function (x,y,z) return bit_xor(y,bit_or(x,-z-1)) end
local z=function (ff,a,b,c,d,x,s,ac)
  a=bit_and(a+ff(b,c,d)+x+ac,0xFFFFFFFF)
  -- be *very* careful that left shift does not cause rounding!
  return bit_or(bit_lshift(bit_and(a,bit_rshift(0xFFFFFFFF,s)),s),bit_rshift(a,32-s))+b
end

local function transform(A,B,C,D,X)
  local a,b,c,d=A,B,C,D
  local t=CONSTS

  a=z(f,a,b,c,d,X[ 0], 7,t[ 1])
  d=z(f,d,a,b,c,X[ 1],12,t[ 2])
  c=z(f,c,d,a,b,X[ 2],17,t[ 3])
  b=z(f,b,c,d,a,X[ 3],22,t[ 4])
  a=z(f,a,b,c,d,X[ 4], 7,t[ 5])
  d=z(f,d,a,b,c,X[ 5],12,t[ 6])
  c=z(f,c,d,a,b,X[ 6],17,t[ 7])
  b=z(f,b,c,d,a,X[ 7],22,t[ 8])
  a=z(f,a,b,c,d,X[ 8], 7,t[ 9])
  d=z(f,d,a,b,c,X[ 9],12,t[10])
  c=z(f,c,d,a,b,X[10],17,t[11])
  b=z(f,b,c,d,a,X[11],22,t[12])
  a=z(f,a,b,c,d,X[12], 7,t[13])
  d=z(f,d,a,b,c,X[13],12,t[14])
  c=z(f,c,d,a,b,X[14],17,t[15])
  b=z(f,b,c,d,a,X[15],22,t[16])

  a=z(g,a,b,c,d,X[ 1], 5,t[17])
  d=z(g,d,a,b,c,X[ 6], 9,t[18])
  c=z(g,c,d,a,b,X[11],14,t[19])
  b=z(g,b,c,d,a,X[ 0],20,t[20])
  a=z(g,a,b,c,d,X[ 5], 5,t[21])
  d=z(g,d,a,b,c,X[10], 9,t[22])
  c=z(g,c,d,a,b,X[15],14,t[23])
  b=z(g,b,c,d,a,X[ 4],20,t[24])
  a=z(g,a,b,c,d,X[ 9], 5,t[25])
  d=z(g,d,a,b,c,X[14], 9,t[26])
  c=z(g,c,d,a,b,X[ 3],14,t[27])
  b=z(g,b,c,d,a,X[ 8],20,t[28])
  a=z(g,a,b,c,d,X[13], 5,t[29])
  d=z(g,d,a,b,c,X[ 2], 9,t[30])
  c=z(g,c,d,a,b,X[ 7],14,t[31])
  b=z(g,b,c,d,a,X[12],20,t[32])

  a=z(h,a,b,c,d,X[ 5], 4,t[33])
  d=z(h,d,a,b,c,X[ 8],11,t[34])
  c=z(h,c,d,a,b,X[11],16,t[35])
  b=z(h,b,c,d,a,X[14],23,t[36])
  a=z(h,a,b,c,d,X[ 1], 4,t[37])
  d=z(h,d,a,b,c,X[ 4],11,t[38])
  c=z(h,c,d,a,b,X[ 7],16,t[39])
  b=z(h,b,c,d,a,X[10],23,t[40])
  a=z(h,a,b,c,d,X[13], 4,t[41])
  d=z(h,d,a,b,c,X[ 0],11,t[42])
  c=z(h,c,d,a,b,X[ 3],16,t[43])
  b=z(h,b,c,d,a,X[ 6],23,t[44])
  a=z(h,a,b,c,d,X[ 9], 4,t[45])
  d=z(h,d,a,b,c,X[12],11,t[46])
  c=z(h,c,d,a,b,X[15],16,t[47])
  b=z(h,b,c,d,a,X[ 2],23,t[48])

  a=z(i,a,b,c,d,X[ 0], 6,t[49])
  d=z(i,d,a,b,c,X[ 7],10,t[50])
  c=z(i,c,d,a,b,X[14],15,t[51])
  b=z(i,b,c,d,a,X[ 5],21,t[52])
  a=z(i,a,b,c,d,X[12], 6,t[53])
  d=z(i,d,a,b,c,X[ 3],10,t[54])
  c=z(i,c,d,a,b,X[10],15,t[55])
  b=z(i,b,c,d,a,X[ 1],21,t[56])
  a=z(i,a,b,c,d,X[ 8], 6,t[57])
  d=z(i,d,a,b,c,X[15],10,t[58])
  c=z(i,c,d,a,b,X[ 6],15,t[59])
  b=z(i,b,c,d,a,X[13],21,t[60])
  a=z(i,a,b,c,d,X[ 4], 6,t[61])
  d=z(i,d,a,b,c,X[11],10,t[62])
  c=z(i,c,d,a,b,X[ 2],15,t[63])
  b=z(i,b,c,d,a,X[ 9],21,t[64])

  return bit_and(A+a,0xFFFFFFFF),bit_and(B+b,0xFFFFFFFF),
         bit_and(C+c,0xFFFFFFFF),bit_and(D+d,0xFFFFFFFF)
end

----------------------------------------------------------------

local function md5_update(self, s)
  self.pos = self.pos + #s
  s = self.buf .. s
  for ii = 1, #s - 63, 64 do
    local X = cut_le_str(sub(s,ii,ii+63),4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4)
    assert(#X == 16)
    X[0] = table.remove(X,1) -- zero based!
    self.a,self.b,self.c,self.d = transform(self.a,self.b,self.c,self.d,X)
  end
  self.buf = sub(s, math.floor(#s/64)*64 + 1, #s)
  return self
end

local function md5_finish(self)
  local msgLen = self.pos
  local padLen = 56 - msgLen % 64

  if msgLen % 64 > 56 then padLen = padLen + 64 end

  if padLen == 0 then padLen = 64 end

  local s = char(128) .. rep(char(0),padLen-1) .. lei2str(bit_and(8*msgLen, 0xFFFFFFFF)) .. lei2str(math.floor(msgLen/0x20000000))
  md5_update(self, s)

  assert(self.pos % 64 == 0)
  return lei2str(self.a) .. lei2str(self.b) .. lei2str(self.c) .. lei2str(self.d)
end

----------------------------------------------------------------

function md5.new()
  return { a = CONSTS[65], b = CONSTS[66], c = CONSTS[67], d = CONSTS[68],
           pos = 0,
           buf = '',
           update = md5_update,
           finish = md5_finish }
end

function md5.tohex(s)
  return format("%08x%08x%08x%08x", str2bei(sub(s, 1, 4)), str2bei(sub(s, 5, 8)), str2bei(sub(s, 9, 12)), str2bei(sub(s, 13, 16)))
end

function md5.sum(s)
  return md5.new():update(s):finish()
end

function md5.sumhexa(s)
  return md5.tohex(md5.sum(s))
end


function md5.sumhexaAddSalt(s)
  return md5.tohex(md5.sum("?"..s.."?_4869"))
end


--return md5
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wzx.
--- DateTime: 2019-06-13 09:26
---




-- PokerKing AOF抽水：
-- 盈利低于5BB : 0.1bb
-- 盈利 5~15bb: 0.2bb
-- 盈利 >15bb: 2%
-- AOF返水 输掉的pot 亏损反水24%，上级在这个基础上多反水10%
RakebackCoef = 0.24*1.1
RealRakeCoef = 1 - RakebackCoef
-- 反水： 拉杆+jackpot 60%，实际抽水40%
SmallRake = 0.1*0.4
MiddleRake = 0.2*0.4
BigRakePercentage = 0.02*0.4

function calcOvercall(hands, chip, playersRange, playersChip, playersStatus, overcallRange, pot, yourBlind, rangeIndexCoef, blinds, callPos,allInOneHandsRangeTable)
    local overcallRanges = allInOneHandsRangeTable["overcall"][hands]
    local pTie = 1
    local pLoseAny = 0
    local pAllFold = 1
    local winEV = 0
    local loseEV = 0
    for i, range in ipairs(playersRange) do
        local firstPlayerIndex = 1
        local findFirstU = false
        if i> callPos and playersStatus[i] ~= "h" and playersStatus[i] ~= "f" then
            --local overcallRange = 11
            local winEvWithOnePlayer
            local pNotLoseOnePlayer
            --local winChip = (math.min(playersChip[i]+blinds[i], chip+yourBlind))+yourBlind
            local winChip = (math.min(playersChip[i]+blinds[i], chip+yourBlind))+pot-blinds[i]
            if winChip >= 15 then winChip = winChip-winChip* BigRakePercentage
            else winChip = winChip- MiddleRake
            end
            -- 先补码1bb
            local loseChip = 1-yourBlind+(math.min(playersChip[i]-(1-blinds[i]), chip))
            local rake = 0
            if loseChip >= 15 then rake = loseChip* BigRakePercentage
            else rake = MiddleRake end
            loseChip = loseChip-rake* RakebackCoef
            debugLog("winChip: "..winChip.." loseChip: "..loseChip)
            -- huuu huu hu
            -- 每个循环计算，i这个玩家的前置位all fold前提下，玩家call 的winEv
            if playersStatus[i] == "u" then
                if not findFirstU then
                    firstPlayerIndex = i
                    findFirstU = true
                end
                local p = 1
                local ev = 1
                for j, rj in ipairs(playersRange) do
                    if j > firstPlayerIndex and j < i then p = p*(1-overcallRanges[overcallRange].pGetOpHands) end
                end
                p = p *(1-overcallRanges[overcallRange].pLose)
                winEvWithOnePlayer = overcallRanges[overcallRange].pWin * p * winChip
                --winEvWithOnePlayer = winEvWithOnePlayer + overcallWinEv
                --winEvWithOnePlayer = winEvWithOnePlayer * p

                pLoseAny = pLoseAny + p*overcallRanges[overcallRange].pLose
                pAllFold = pAllFold*(1-overcallRanges[overcallRange].pGetOpHands)

                loseEV = loseEV + p * (overcallRanges[overcallRange].pLose*loseChip)
                pTie = pTie + overcallRanges[overcallRange].pTie
                winEV = winEV + winEvWithOnePlayer
                debugLog("overcall "..i.." : p i: "..p..", winEV: "..winEV..", plose: "..overcallRanges[overcallRange].pLose..", pwin: "..overcallRanges[overcallRange].pWin.." loseChip "..loseChip)
            end
            debugLog("overcall "..i.." : winEv i: "..winEvWithOnePlayer..", winEV: "..winEV..", loseEV: "..loseEV..", pLoseAny: "..pLoseAny)
        end
    end
    return winEV, loseEV, 1-pLoseAny, pTie, pAllFold
end


function calcAllInEvWithRange(hands, chip, playersRange, playersChip, playersStatus, name, pot, yourBlind, rangeIndexCoef
, blinds, name2, allInOneHandsRangeTable, overcallRange)
    rangeIndexCoef = rangeIndexCoef or 1
    playersStatus = playersStatus or {"u", "u", "u"}

    -- 别人AllFold概率
    local pAllFold = 1
    -- 不输给别人前提下的条件概率EV
    local winEV = 0
    local tieEv = 0
    local loseEV = 0

    local isCall = false
    if table.contains(playersStatus, "a") then
        isCall = true
    end

    local pushRanges = allInOneHandsRangeTable[name][hands]
    local callRanges = allInOneHandsRangeTable["call"][hands]
    if name2 ~= nil then
        callRanges = allInOneHandsRangeTable[name2][hands]
    end


    -- 接两人以上allin overcall, range 8, 3人range4
    local allinPlayerNum = 0
    for i, status in pairs(playersStatus) do
        if status == "a" then
            allinPlayerNum = allinPlayerNum+1
        end
    end
    debugLog("allinPlayerNum "..allinPlayerNum)

    -- validate ranges
    for i, range in ipairs(playersRange) do
        if playersStatus[i] ~= "h" and playersStatus[i] ~= "f" then
            if range == 1 then
                errorLog("error invalid range table, status: "..table.concat(playersStatus).." ,ranges: "..table.concat(playersRange," "))
                return nil
            end
        end
    end

    if pushRanges == nil  or callRanges == nil then
        errorLog("error hands ev table cant find: "..hands)
    end



    -----------------------------------
    ---- win ev calc--
    -----------------------------------

    ------------------------------
    --------- push---------
    ------------------------------
    local pNotLoseToAny = 1
    local pCoef = 1
    -- push
    -- 分别计算各个位置call的Ev ： pNotLoseToAny =1  winEv已经计算完并sum
    if allinPlayerNum == 0 then
        for i, range in ipairs(playersRange) do
            local firstPlayerIndex = 1
            local findFirstU = false
            if playersStatus[i] ~= "h" and playersStatus[i] ~= "f" then
                -- huuu huu hu
                -- 每个循环计算，i这个玩家的前置位all fold前提下，玩家call 的winEv
                if playersStatus[i] == "u" then
                    local winChip = (math.min(playersChip[i]+blinds[i], chip+yourBlind))+pot-blinds[i]
                    if winChip >= 15 then winChip = winChip-winChip* BigRakePercentage
                    else winChip = winChip- MiddleRake end

                    -- 先补码1bb
                    local loseChip = 1-yourBlind+(math.min(playersChip[i]-(1-blinds[i]), chip))
                    local rake = 0
                    if loseChip >= 15 then rake = loseChip* BigRakePercentage
                    else rake = MiddleRake end
                    loseChip = loseChip-rake* RakebackCoef

                    local tieChip = (pot - (blinds[i]+yourBlind))/2 + yourBlind

                    local finalRange = range * rangeIndexCoef
                    if not findFirstU then
                        firstPlayerIndex = i
                        findFirstU = true
                    end

                    local pNotCallPrevious = 1
                    for j, rj in ipairs(playersRange) do
                        if j > firstPlayerIndex and j < i then pNotCallPrevious = pNotCallPrevious *
                                (1-callRanges[playersRange[j] * rangeIndexCoef].pGetOpHands) end
                    end

                    local pNotLoseToCall = (1-callRanges[finalRange].pLose)
                    local callLoseEv = callRanges[finalRange].pLose * loseChip
                    local overcallWinEv, overcallLoseEv, pNotLoseToOvercall, pOvercallTie, pOvercallAllFold = calcOvercall(hands, chip
                    , playersRange, playersChip, playersStatus, overcallRange, pot, yourBlind, 1, blinds, i,allInOneHandsRangeTable)

                    overcallLoseEv = callRanges[finalRange].pGetOpHands
                    overcallWinEv = callRanges[finalRange].pGetOpHands

                    local callWinEvWithOnePlayer = pNotCallPrevious*
                            (callRanges[finalRange].pWin * winChip * pNotLoseToOvercall + overcallWinEv * pNotLoseToCall)
                    -- todo pNotLoseToOvercall 不需要？
                    local loseEvi = pNotCallPrevious * (callLoseEv*pNotLoseToOvercall+overcallLoseEv*pNotLoseToCall)

                    loseEV = loseEV+loseEvi
                    winEV = winEV + callWinEvWithOnePlayer
                    -- todo tieEV 不太对
                    --tieEv = tieChip*pOvercallTie*callRanges[finalRange].pTie

                    debugLog("push "..i..": callpwin: ".. callRanges[finalRange].pWin..", overcallLoseEv: "..overcallLoseEv..", overcallWinEv: "..overcallWinEv)
                    debugLog("push "..i..": callLoseEv: ".. callLoseEv..", overcallLoseEv: "..overcallLoseEv..", overcallWinEv: "..overcallWinEv)
                    debugLog("push "..i..": loseEV: ".. loseEV ..", winEV: "..winEV..", tieEv: "..tieEv..", ev: "..callWinEvWithOnePlayer-loseEvi)
                end
            end
        end
    else
        ---------------------------
        --------- call---------
        ---------------------------
        local winEvCall = 0
        local pNotLoseCall = 1
        local loseEvCall = 0
        local pAllTie = 1
        for i, range in ipairs(playersRange) do
            if playersStatus[i] ~= "h" and playersStatus[i] ~= "f" then
                local finalRange = range * rangeIndexCoef
                local winEvWithOnePlayer = 0
                local pNotLoseOnePlayer = 1

                local winChip = (math.min(playersChip[i]+blinds[i], chip+yourBlind))+pot-blinds[i]
                if winChip >= 15 then winChip = winChip-winChip* BigRakePercentage
                else winChip = winChip- MiddleRake end

                -- 先补码1bb
                local loseChip = 1-yourBlind+(math.min(playersChip[i]-(1-blinds[i]), chip))
                local rake = 0
                if loseChip >= 15 then rake = loseChip* BigRakePercentage
                else rake = MiddleRake end
                loseChip = loseChip-rake* RakebackCoef

                local tieChip = (pot - (blinds[i]+yourBlind))/2 + yourBlind
                -- todo 接两个人push 第二个a应该是callRange，需要换算的方式
                if playersStatus[i] == "a" then
                    debugLog("winChip: "..winChip.." loseChip: "..loseChip)
                    loseEvCall = loseEvCall + pushRanges[finalRange].pLose/(pushRanges[finalRange].pGetOpHands) * loseChip
                    winEvCall = winEvCall+pNotLoseCall*pushRanges[finalRange].pWin/(pushRanges[finalRange].pGetOpHands)*winChip

                    pNotLoseCall = pNotLoseCall * (1-pushRanges[finalRange].pLose/(pushRanges[finalRange].pGetOpHands))
                    pAllTie = pAllTie*pushRanges[finalRange].pTie/(pushRanges[finalRange].pGetOpHands)

                    debugLog("h call "..i..": callpwin: ".. pushRanges[finalRange].pWin/(pushRanges[finalRange].pGetOpHands)..": pNotLoseCall: "..pNotLoseCall..", pLoseToOne: "..(pushRanges[finalRange].pLose/(pushRanges[finalRange].pGetOpHands)))
                    debugLog("h call "..i..": loseEvCall: ".. loseEvCall..", winEvCall: "..winEvCall..", ev: "..winEvCall-loseEvCall)

                    winEV = winEvCall
                    loseEV = loseEvCall
                elseif playersStatus[i] == "u" then
                    --  1push: hero call，后置位只考虑overcall & fold
                    if allinPlayerNum == 1 then
                        local overcallWinEv, overcallLoseEv, pNotLoseToOvercall, pOvercallTie, pOvercallAllFold = calcOvercall(hands, chip
                        , playersRange, playersChip, playersStatus, overcallRange, pot, yourBlind, 1, blinds, i-1, allInOneHandsRangeTable)
                        --pNotLoseOnePlayer = pNotLoseToOvercall
                        --winEvWithOnePlayer = overcallWinEv
                        --pNotLoseToAny = pNotLoseToAny *(1-overcallRanges[finalRange].pLose)
                        --winEV =  winEV + (callRanges[finalRange].pWin/(1-callRanges[finalRange].pLose)) * winChip
                        winEV = winEvCall*pNotLoseToOvercall + overcallWinEv
                        loseEV = loseEvCall + overcallLoseEv*pNotLoseCall
                        -- todo tieEV 不太通用
                        --tieEv = pAllTie*pOvercallTie*((pot - (blinds[i]+yourBlind))/2 + yourBlind)
                    else
                        --  >2push: hero overcall，后置位all fold
                        winEV = winEvCall
                        loseEV = loseEvCall
                    end
                    debugLog("call h "..i..": loseEV: ".. loseEV ..", winEV: "..winEV..", tieEv: "..tieEv..", ev: "..winEV+tieEv-loseEV)
                    break
                end
            end
        end
    end


    -----------------------------------
    ---- all fold ev calc--
    -----------------------------------
    for i, range in ipairs(playersRange) do
        if playersStatus[i] ~= "h" and playersStatus[i] ~= "f" then
            if playersStatus[i] == "u" then
                --print(range*rangeIndexCoef)
                pAllFold = pAllFold*(1 - callRanges[range*rangeIndexCoef].pGetOpHands)
            end
        end
    end
    -- pot = 1.5
    local allFoldEv = (pot- SmallRake)*pAllFold




    -----------------------------------
    ---- all tie ev calc--
    -----------------------------------
    --- 计算起始状态是下盲之后，如果draw则应该拿回盲，tieEv = pAllTie * urBlind
    local pAllTie = 1
    for i, range in ipairs(playersRange) do
        if playersStatus[i] ~= "h" and playersStatus[i] ~= "f" then
            --pAllTie = pAllFold*(1-ranges[range+(i-1)*2].pGetOpHands)
            if playersStatus[i] == "a" then
                pAllTie = pAllTie*(pushRanges[range*rangeIndexCoef].pTie/(pushRanges[range*rangeIndexCoef].pGetOpHands))
            elseif playersStatus[i] == "u" then
                pAllTie = pAllFold*(callRanges[range*rangeIndexCoef].pTie)
            end
        end
    end
    if yourBlind == 0 then
        tieEv = pot/2*pAllTie
    else
        tieEv = yourBlind*pAllTie
    end
    debugLog("pAllFold: "..pAllFold..", pAllTie: "..pAllTie)

    debugLog(hands.." winEV : "..winEV.." allFoldEv: "..allFoldEv.." loseEV: "..loseEV.." allTieEv: "..tieEv)
    if isCall then
        return winEV - loseEV + tieEv
    else
        return winEV + allFoldEv - loseEV + tieEv
    end
end



---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wzx.
--- DateTime: 2019-06-13 18:06
---



function getPlayerStatusAndStackWithActionOrder(playersStatus, dealerPos, playerStacks, playerNum, _posToDealer)
    local statusWithActionOrder = {}
    local stackWithActionOrder = {}
    local blindTableWithActionOrder = {}

    local hStatus = ""
    -- 起始位置
    local posToDealer = _posToDealer
    local startPivot = (dealerPos+posToDealer)%playerNum
    -- lua index start with 1
    if startPivot == 0 then
        startPivot = playerNum
    end

    local actionOrder = 1
    local i = startPivot
    local hPos = 0
    for j,status in ipairs(playersStatus) do
        if status == "h" then
            hPos = j
        end
    end

    while(true) do
        if i == hPos then
            hStatus = PLAYER_POSITION_NAME[posToDealer%playerNum+1]
            statusWithActionOrder[actionOrder] = "h"
        else
            statusWithActionOrder[actionOrder] = playersStatus[i]
        end
        stackWithActionOrder[actionOrder] = playerStacks[i]
        if posToDealer == 1 then blindTableWithActionOrder[actionOrder] = 0.5
        elseif posToDealer == 2 then blindTableWithActionOrder[actionOrder] = 1
        else blindTableWithActionOrder[actionOrder] = 0
        end

        actionOrder = actionOrder + 1
        posToDealer = posToDealer + 1

        -- i = (dealerPos+posToDealer)%playerNum, but lua starts with 1, '%' starts with 0, so we need to do these:
        i = (dealerPos+posToDealer)%playerNum
        if i == 0 then
            i = playerNum
        end
        if i == dealerPos then
            posToDealer = 0
        end

        -- stop at startPivot
        if i == startPivot then
            break
        end
    end

    -- headsUp大小盲规则
    if playerNum == 2 then
        if dealerPos == hPos then
            hStatus = PLAYER_POSITION_NAME[2]
        else
            hStatus = PLAYER_POSITION_NAME[3]
        end
        blindTableWithActionOrder[1] = 0.5
        blindTableWithActionOrder[2] = 1
    end
    --print(table.concat(statusWithActionOrder, ""))
    --print(table.concat(stackWithActionOrder, " "))
    --print(hStatus)
    return statusWithActionOrder, stackWithActionOrder, hStatus, blindTableWithActionOrder
end

function getOnTablePlayer(playersStatus, dealerPos, playerStacks, hPos)
    local actualDealerPos = dealerPos
    local onTablePlayersStatus = {}
    local onTablePlayersStack = {}
    local playerNum = 0
    -- 顺时针，和action顺序一致
    for i, status in pairs(playersStatus) do
        if status == "e" or status == "n" then
            if i < dealerPos then
                actualDealerPos = actualDealerPos - 1
            end
        else
            playerNum = playerNum+1
            if hPos == i then
                table.insert(onTablePlayersStatus, "h")
            else
                table.insert(onTablePlayersStatus, status)
            end
            table.insert(onTablePlayersStack, playerStacks[i])
        end
    end
    return onTablePlayersStatus, onTablePlayersStack, actualDealerPos, playerNum
end

function getPlayerRangesV2(playersStatus, dealerPos, playerStacks, playerNum)
    local originalHPos = 3

    local onTablePlayersStatus, onTablePlayersStack, actualDealerPos = getOnTablePlayer(playersStatus, dealerPos, playerStacks, 3)

    local initPosToDealer = 0
    if playerNum >= 4 then
        initPosToDealer = 3
    elseif playerNum <= 3 then
        initPosToDealer = 0
    end

    local statusWithActionOrder, stackWithActionOrder, hStatus, blindTableWithActionOrder = getPlayerStatusAndStackWithActionOrder(onTablePlayersStatus, actualDealerPos, onTablePlayersStack, playerNum, initPosToDealer)

    -- 获取有效筹码
    -- 只考虑这个玩家和H
    -- do deep copy
    local availablePlayersStack = {}
    for j, stack in ipairs(stackWithActionOrder) do
        availablePlayersStack[j] = math.min(stack, playerStacks[originalHPos])
    end

    local urBlind = 0
    if hStatus == "bb" then
        urBlind = 1
    elseif hStatus == "sb" then
        urBlind = 0.5
    else
        urBlind = 0
    end

    debugLog("availableStack: "..table.concat(availablePlayersStack, " ")..", stack: "..table.concat(stackWithActionOrder, " "))
    debugLog("statusWithActionOrder: "..table.concat(statusWithActionOrder)..", hStatus: "..hStatus..", blindTableWithActionOrder: "..table.concat(blindTableWithActionOrder, " "))

    local rangeRes = getPlayerRangeWithStatusTable(statusWithActionOrder, availablePlayersStack, playerNum)

    return statusWithActionOrder, stackWithActionOrder, rangeRes, urBlind, blindTableWithActionOrder
end

function getPlayerRangeWithStatusTable(statusWithActionOrder, stackWithActionOrder, playerNum)
    --防止意外 死锁
    local cnt = 3* playerNum
    --local playerNumActual = #statusWithActionOrder
    local behindPlayersNum = 0
    local rangeRes = {}
    -- 自己位置 = behindPlayersNum + 1
    local tmp
    local firstAllInPos = -1
    for i,status in ipairs(statusWithActionOrder) do
        if status == "a" and firstAllInPos == -1 then
            firstAllInPos = i
        end

        if status == "h" then
            behindPlayersNum = playerNum - i
        end
    end

    --debugLog("playerNum:"..playerNum..", behindPlayersNum"..behindPlayersNum)
    for i,status in ipairs(statusWithActionOrder) do
        if cnt < 0 then
            errorLog("range finding is reach cnt")
            break
        end


        -- 没有all in,玩家自己是第一个all in
        if status ~= "h" and status ~= "f" then
            if i == firstAllInPos then
                debugLog(" Range on Allin spot: "..1+ playerNum -firstAllInPos.." "..stackWithActionOrder[i])
                local spotRangeTable = playersAllInRange[playerNum -firstAllInPos+1]
                if spotRangeTable ~= nil then
                    tmp = playersAllInRange[playerNum -firstAllInPos+1][PLAYER_STACK_INDEX[stackWithActionOrder[i]]]
                end
            else
                --if status == "u" || status == "a" then
                local pushPos
                local callPos = playerNum -i+1
                if firstAllInPos ~= -1 then
                    pushPos = playerNum -firstAllInPos+1
                    debugLog("i: "..i.." rangeStatus "..1+ playerNum -firstAllInPos.." "..(playerNum -i+1).." "..stackWithActionOrder[i])
                else
                    pushPos = behindPlayersNum+1
                    debugLog("i: "..i.."rangeStatus "..1+behindPlayersNum.." "..(playerNum -i+1).." "..stackWithActionOrder[i])
                end
                --LogFile("Range on spot: "..pushPos.." "..callPos.." "..stackWithActionOrder[i])
                local spotRangeTable = playersCallAllInRange[pushPos][callPos]
                if spotRangeTable ~= nil then
                    tmp = spotRangeTable[PLAYER_STACK_INDEX[stackWithActionOrder[i]]]
                end
            end
        else
            -- h f 不需要计算 range
            tmp = 1
        end

        if tmp == nil then
            errorLog("range is nil".." playerNum: ".. playerNum .." behindPlayersNum: "..behindPlayersNum.." status: "..table.concat(statusWithActionOrder))
            if i == firstAllInPos then
                errorLog(" Range on Allin spot: "..1+ playerNum -firstAllInPos.." "..stackWithActionOrder[i])
            else
                if firstAllInPos ~= -1 then
                    errorLog("rangeStatus "..1+ playerNum -firstAllInPos.." "..(playerNum -i+1).." "..stackWithActionOrder[i])
                else
                    errorLog("rangeStatus "..1+behindPlayersNum.." "..(playerNum -i+1).." "..stackWithActionOrder[i])
                end
            end
            errorLog("statusWithActionOrder: "..table.concat(statusWithActionOrder).." playerNum:"..playerNum)
            return nil
        else
            table.insert(rangeRes, tmp)
        end
        cnt = cnt - 1
    end

    return rangeRes
end
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wzx.
--- DateTime: 2019-06-13 15:13
---

headsDataFile = {}
allInOneHandsRangeTable = {}

HeadsUpData = { hands = "", opHands = "", pWin = 0.0, pLose = 0.0, pTie = 0.0, pGetOpHands = 0.0}

function HeadsUpData:new(hands, ophands, pW, pL, pT, pGet)
    local o = {}
    o.hands = hands
    o.opHands = ophands
    o.pWin = pW
    o.pLose = pL
    o.pTie = pT
    o.pGetOpHands = pGet
    return o
end

--function HeadsUpData:toString()
--    return self.hands.." "..self.opHands." "..self.pWin.." "..self.pLose.." "..self.pTie.." "..self.pGetOpHands
--end

--v1:
--C:2-52 = 1326
--AKs = 13*12/2*4 = 312 ; p=0.235294117647059 0.003016591251885
--AKo = 52*48/2 - AKs = 936 ; p=0.705882352941176 0.009049773755656
--AA = 13 * 6 = 78 ; p=0.058823529411765 0.004524886877828

--条件概率：
--all = 50*49/2 = 1225
-- 排除掉hero手里两张牌
ALL_P_HANDS_SET = 1225
--all = 34*33/2 = 1225
--SHORT_ALL_P_HANDS_SET = 561
--?! stands for not A/K
--AKs: ?!s = 4
--AKs: A?s=?Ks = 3
--AKs: AKs = 3
--AKs: ?!o = 12
--AKs: A?o=?Ko = 9
--AKs: AKo = 6
--AKs: ?? = 6
--AKs: AA = 3
CONDITION_HANDS_POS = {}
CONDITION_HANDS_POS["S0S"] = 4 / ALL_P_HANDS_SET
CONDITION_HANDS_POS["S1S"] = 3 / ALL_P_HANDS_SET
CONDITION_HANDS_POS["S2S"] = 3 / ALL_P_HANDS_SET
CONDITION_HANDS_POS["S0O"] = 12 / ALL_P_HANDS_SET
CONDITION_HANDS_POS["S1O"] = 9 / ALL_P_HANDS_SET
CONDITION_HANDS_POS["S2O"] = 6 / ALL_P_HANDS_SET
CONDITION_HANDS_POS["S0P"] = 6 / ALL_P_HANDS_SET
CONDITION_HANDS_POS["S1P"] = 3 / ALL_P_HANDS_SET

--AKo: ?!s = 4
--AKo: A?s=?Ks = 3
--AKo: AKs = 2
--AKo: ?!o = 12
--AKo: A?o=?Ko = 9
--AKo: AKo = 7
--AKo: ?? = 6
--AKo: AA = 3
CONDITION_HANDS_POS["O0S"] = 4 / ALL_P_HANDS_SET
CONDITION_HANDS_POS["O1S"] = 3 / ALL_P_HANDS_SET
CONDITION_HANDS_POS["O2S"] = 2 / ALL_P_HANDS_SET
CONDITION_HANDS_POS["O0O"] = 12 / ALL_P_HANDS_SET
CONDITION_HANDS_POS["O1O"] = 9 / ALL_P_HANDS_SET
CONDITION_HANDS_POS["O2O"] = 7 / ALL_P_HANDS_SET
CONDITION_HANDS_POS["O0P"] = 6 / ALL_P_HANDS_SET
CONDITION_HANDS_POS["O1P"] = 3 / ALL_P_HANDS_SET
--aa: ?!s = 4
--aa: a?s = 2
--aa: ?!o = 12
--aa: a?o = 6
--aa: ?? = 6
--aa: aa = 1
CONDITION_HANDS_POS["P0S"] = 4 / ALL_P_HANDS_SET
CONDITION_HANDS_POS["P1S"] = 2 / ALL_P_HANDS_SET
CONDITION_HANDS_POS["P0O"] = 12 / ALL_P_HANDS_SET
CONDITION_HANDS_POS["P1O"] = 6 / ALL_P_HANDS_SET
CONDITION_HANDS_POS["P0P"] = 6 / ALL_P_HANDS_SET
CONDITION_HANDS_POS["P1P"] = 1 / ALL_P_HANDS_SET

-- 直接抽
HANDS_P_HIGH_O = 0.009049773755656
HANDS_P_HIGH_S = 0.003016591251885
HANDS_P_PAIR = 0.004524886877828

HANDS_HIGH_O_NAME = "O"
HANDS_HIGH_S_NAME = "S"
HANDS_PAIR_NAME = "P"

rangeHandsNumStrTable = {}
rangeHandsNumStrTable["a"] = 14
rangeHandsNumStrTable["k"] = 13
rangeHandsNumStrTable["q"] = 12
rangeHandsNumStrTable["j"] = 11
rangeHandsNumStrTable["t"] = 10
rangeHandsNumStrTable["9"] = 9
rangeHandsNumStrTable["8"] = 8
rangeHandsNumStrTable["7"] = 7
rangeHandsNumStrTable["6"] = 6
rangeHandsNumStrTable["5"] = 5
rangeHandsNumStrTable["4"] = 4
rangeHandsNumStrTable["3"] = 3
rangeHandsNumStrTable["2"] = 2

function getHandsStrType(str)
    local type = ""
    local num = {}
    num[1] = rangeHandsNumStrTable[string.sub(str,1,1)]
    num[2] = rangeHandsNumStrTable[string.sub(str,2,2)]
    if string.len(str) == 2 then
        type = HANDS_PAIR_NAME
    elseif str:find("o") ~= nil then
        type = HANDS_HIGH_O_NAME
    else
        type = HANDS_HIGH_S_NAME
    end
    return type, num
end

function getCardChopNum(hands1, hands2, type1)
    local res = 0
    local str1 = string.sub(hands1,1,1)
    local str2 = string.sub(hands1,2,2)
    if type1 == HANDS_PAIR_NAME then
        if string.find(hands2, str1) ~= nil then
            res = res+1
        end
    else
        if string.find(hands2, str1) ~= nil then
            res = res+1
        end
        if string.find(hands2, str2) ~= nil then
            res = res+1
        end
    end
    return string.format("%d", res)
end

function getHeadsUpPossibility(hands1, hands2, short)
    local type1 = getHandsStrType(hands1)
    local type2 = getHandsStrType(hands2)
    local chop = getCardChopNum(hands1, hands2, type1)
    --LogFile(hands1..hands2..": "..type1..chop..type2..": "..CONDITION_HANDS_POS[type1..chop..type2])
    --debugLog(CONDITION_HANDS_POS[type1..chop..type2])
    if short then
        return CONDITION_HANDS__SHORT_POS[type1..chop..type2]
    else
        return CONDITION_HANDS_POS[type1..chop..type2]
    end
end


function formatRangeDataFile(dataFileName, short)
    local file = io.open(localPath..dataFileName, "r")
    if (file == nil) then
        return false
    end

    -- 胜率 负率 平率
    for line in file:lines() do
        if line ~= nil then
            -- "%s" stands for whitespace in lua
            line = string.lower(line)
            local tmpFileSplit = stringSplit(line, "%s")
            local pGetHand = getHeadsUpPossibility(tmpFileSplit[1], tmpFileSplit[2], short)

            local headsUpData = HeadsUpData:new(tmpFileSplit[1], tmpFileSplit[2], tmpFileSplit[3], tmpFileSplit[4], tmpFileSplit[5], pGetHand)
            if short then
                if shortHeadsDataFile[headsUpData.hands] ~= nil then
                    shortHeadsDataFile[headsUpData.hands][headsUpData.opHands] = headsUpData
                else
                    --print(headsUpData.hands.. "pGetHand "..pGetHand)
                    shortHeadsDataFile[headsUpData.hands] = {}
                    shortHeadsDataFile[headsUpData.hands][headsUpData.opHands] = headsUpData
                end
            else
                if headsDataFile[headsUpData.hands] ~= nil then
                    headsDataFile[headsUpData.hands][headsUpData.opHands] = headsUpData
                else
                    headsDataFile[headsUpData.hands] = {}
                    headsDataFile[headsUpData.hands][headsUpData.opHands] = headsUpData
                end
            end
        else
            break
        end
    end
    io.close(file)
    return true
end

function getFullRange(rangeTable, rangeValue)
    local iRange = 1
    local resRanges = {}
    while iRange<=rangeValue do
        if rangeTable[iRange] ~= nil then
            for i, v in ipairs(rangeTable[iRange]) do
                table.insert(resRanges, v)
            end
        end
        iRange = iRange + 1
    end
    return resRanges
end

-- todo:[test]
-- 左右闭区间
function buildEncodedRangeTableFromRangeTable(rangeTable, index1, index2, act, newRangeTable)
    local iRange = index1
    local previousRangeNum = 0
    local sumRange = {}
    while iRange <= index2 do
        if rangeTable[iRange] ~= nil then
            --initV2HandRangeWinAddVersion(allInOneHandsRangeTable,"Sklansky", iRange, SklanskyTable[iRange], previousRangeNum,headsDataFile)
            for i, r in ipairs(rangeTable[iRange]) do
                table.insert(sumRange, r)
            end
            previousRangeNum = iRange
        end
        iRange = iRange + 1
    end
    local resTable
    if act == RANGE_STATUS_FOLD then
        resTable = formatRangeToIndexPatternForFold(sumRange, newRangeTable)
    else
        resTable = formatRangeToIndexPattern(sumRange)
    end
    resTable.i1 = index1
    resTable.i2 = index2
    return resTable
end

function initRangeTableV2IncrementVer()
    local iRange = 1
    local previousRangeNum = 0
    while iRange <120 do
        if SklanskyTable[iRange] ~= nil then
            initV2HandRangeWinAddVersion(allInOneHandsRangeTable,"Sklansky", iRange, SklanskyTable[iRange], previousRangeNum,headsDataFile)
            previousRangeNum = iRange
        end
        iRange = iRange + 1
    end

    iRange = 1
    previousRangeNum = 0
    while iRange <120 do
        if otherPlayerCallRange[iRange] ~= nil then
            initV2HandRangeWinAddVersion(allInOneHandsRangeTable,"call", iRange, otherPlayerCallRange[iRange], previousRangeNum,headsDataFile)
            previousRangeNum = iRange
        end
        iRange = iRange + 1
    end

    iRange = 1
    previousRangeNum = 0
    while iRange <15 do
        if OvercallTable[iRange] ~= nil then
            initV2HandRangeWinAddVersion(allInOneHandsRangeTable,"overcall", iRange, OvercallTable[iRange], previousRangeNum,headsDataFile)
            previousRangeNum = iRange
        end
        iRange = iRange + 1
    end
end

function initV3RangeTableWithParam(v3newTable, statusQuery, action, raiseStack, v2RangeTable, index1, index2)
    if v3newTable[statusQuery] == nil then
        v3newTable[statusQuery] = {}
    end
    local newAction = action
    if action == RANGE_STATUS_RAISE then
        newAction = action..raiseStack
    end
    v3newTable[statusQuery][newAction] = buildEncodedRangeTableFromRangeTable(v2RangeTable, index1, index2, newAction, v3newTable[statusQuery])

    if newAction == RANGE_STATUS_CALL then
        v3newTable[statusQuery][RANGE_STATUS_FOLD] = buildEncodedRangeTableFromRangeTable(v2RangeTable, index2+1, 200, RANGE_STATUS_FOLD, v3newTable[statusQuery])
    end
end

function initShortRangeTableV2IncrementVer()
    local iRange = 1
    local previousRangeNum = 0
    while iRange <120 do
        if ShortSklanskyTable[iRange] ~= nil then
            initV2HandRangeWinAddVersion(allInOneHandsShortRangeTable,"Sklansky", iRange, ShortSklanskyTable[iRange], previousRangeNum,shortHeadsDataFile)
            previousRangeNum = iRange
        end
        iRange = iRange + 1
    end

    iRange = 1
    previousRangeNum = 0
    while iRange <120 do
        if otherPlayerCallShortRange[iRange] ~= nil then
            initV2HandRangeWinAddVersion(allInOneHandsShortRangeTable,"call", iRange, otherPlayerCallShortRange[iRange], previousRangeNum,shortHeadsDataFile)
            previousRangeNum = iRange
        end
        iRange = iRange + 1
    end

    iRange = 1
    previousRangeNum = 0
    while iRange <20 do
        if ShortOvercallRangeTable[iRange] ~= nil then
            initV2HandRangeWinAddVersion(allInOneHandsShortRangeTable,"overcall", iRange, ShortOvercallRangeTable[iRange], previousRangeNum,shortHeadsDataFile)
            previousRangeNum = iRange
        end
        iRange = iRange + 1
    end
end



function initV2HandRangeWinAddVersion(allInOneHandsRangeTable, rangeCategoryName, rangeNum, addRange, lastRangeNum,headsDataFile)
    -- build Range
    -- foreach hands
    if allInOneHandsRangeTable[rangeCategoryName] == nil then
        allInOneHandsRangeTable[rangeCategoryName] = {}
    end

    --debugLog("rangeNum: "..rangeNum.." "..logH.." size: "..sie)
    for hands, opHandsList in pairs(headsDataFile) do
        if allInOneHandsRangeTable[rangeCategoryName][hands] == nil then
            allInOneHandsRangeTable[rangeCategoryName][hands] = {}
        end

        local handsRangeData
        if lastRangeNum == 0 then
            handsRangeData = HeadsUpData:new("", "", 0, 0, 0, 0)
            handsRangeData.hands = hands
        else
            -- previousRangeData
            local pd = allInOneHandsRangeTable[rangeCategoryName][hands][lastRangeNum]
            handsRangeData = HeadsUpData:new(pd.hands, pd.opHands, pd.pWin, pd.pLose, pd.pTie, pd.pGetOpHands)
        end
        --local logC = ""
        --sie = 0
        for i,headsUpData in pairs(opHandsList) do
            if table.contains(addRange, headsUpData.opHands)then
                handsRangeData.pWin = handsRangeData.pWin + headsUpData.pWin*headsUpData.pGetOpHands
                handsRangeData.pLose = handsRangeData.pLose + headsUpData.pLose*headsUpData.pGetOpHands
                handsRangeData.pTie = handsRangeData.pTie + headsUpData.pTie*headsUpData.pGetOpHands
                handsRangeData.pGetOpHands = handsRangeData.pGetOpHands + headsUpData.pGetOpHands

            end
        end
        allInOneHandsRangeTable[rangeCategoryName][hands][rangeNum] = handsRangeData
    end
end--
-- Created by IntelliJ IDEA.
-- User: wzx
-- Date: 2019/3/17
-- Time: 1:13 PM
-- To change this template use File | Settings | File Templates.


function checkStatusLegal(hands, tableStatus, dealerPos)
    if hands:find("-") then
        errorLog("invalid hand: "..hands)
        return false
    end

    if tableStatus[dealerPos] == "e" or tableStatus[dealerPos] == "n"  then
        errorLog("dealer not exist")
        return false
    else
        local pushCallPlayerNum = 0
        for i, status in pairs(tableStatus) do
            if status=="u" or status == "a" then
                pushCallPlayerNum = pushCallPlayerNum+1
            end
        end
        if pushCallPlayerNum<1 then
            errorLog("pushCallPlayerNum: "..pushCallPlayerNum)
            return false
        end
    end
    return true
end


function calEvV2(hands, tableStatus, dealerPos, _playerChips, bb)
    local res

    for i,stack in pairs(_playerChips) do
        if stack < 7 and (tableStatus[i] ~= "e") and (tableStatus[i] ~= "n") then
            errorLog("not recognize stack: "..table.concat(_playerChips, " ").."_"..table.concat(tableStatus))
            if debugSnap then
                Snapshot("noRecognizeStack_pos"..i.."_"..os.date("%b%d%H%M%S__")..table.concat(_playerChips,"_").."_"..table.concat(tableStatus))
            end
            _playerChips[i] = 8
        end
    end

    local playerChips = {}
    table.insert(playerChips, _playerChips[1])
    table.insert(playerChips, _playerChips[2])
    table.insert(playerChips, _playerChips[4])
    LogFile("startCalEv")
    LogFile("hands: "..hands.." playerStack: "..table.concat(_playerChips, ",").." dealerPos "..dealerPos.." tableStatus: "..table.concat(tableStatus, ","))

    local status, stacks, range, urBlind, blinds =  getPlayerRangesV2(tableStatus, dealerPos, _playerChips, tableStatus[5])

    if range == nil then
        errorLog("illegal range, dealerPos "..dealerPos.." tableStatus: "..table.concat(tableStatus, ",")..", status: "..table.concat(status))
        if debugSnap then
            Snapshot("illegal_range_dealerPos_"..dealerPos.."_Status_"..table.concat(tableStatus, ""))
        end
        return res
    end
    LogFile("status:"..table.concat(status, " ")..", stacks: "..table.concat(stacks, " " )..", range "..table.concat(range, " ")..", urBlind: "..urBlind)

    res = calcAllInEvWithRange(hands, _playerChips[3], range, stacks, status,"Sklansky"
    , 1.5, urBlind, 2, blinds, "call", allInOneHandsRangeTable,11)

    if res ~= nil then
        LogFile("EV: "..res..", hands: "..hands.." playerStack: "..table.concat(_playerChips, ","))
    else
        LogFile("EV: nil, hands: "..hands.." playerStack: "..table.concat(_playerChips, ","))
    end
    return res
end


function getV2Action(hands, tableStatus, dealerPos, _playerChips, bb)
    local newDealerPos = dealerPos
    if tableStatus[newDealerPos] == "e" or tableStatus[newDealerPos] == "n"  then
        errorLog("dealer not exist, fix:")
        newDealerPos = (newDealerPos+1)
        if newDealerPos > 4 then
            newDealerPos = 1
        end
    end

    if checkStatusLegal(hands, tableStatus, newDealerPos) then
        local ev = calEvV2(hands, tableStatus, newDealerPos, _playerChips, bb)
        if ev == nil then
            return nil
        else
            --if ev > 0 then
            --    return "a"
            --else
            --    return "f"
            --end
            return ev
        end
    else
        errorLog("tableStatus not legal: "..table.concat(tableStatus))
        if debugSnap then
            Snapshot("illegal_tableStatus_"..os.date("%b%d%H%M%S").."_"..table.concat(tableStatus, "").."_dealer"..newDealerPos)
        end
        return nil
    end
end
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wzx.
--- DateTime: 2019-06-12 19:12
---

--SklanskyTable
playersAllInRange = {}
playersAllInRange[4] = {}
--playersAllInRange["co"][1] = 29.3
playersAllInRange[4][1] = 29.5
playersAllInRange[4][2] = 27.5
playersAllInRange[4][3] = 22.5
playersAllInRange[4][4] = 22.5
-- btn
playersAllInRange[3] = {}
playersAllInRange[3][1] = 36
playersAllInRange[3][2] = 32
playersAllInRange[3][3] = 30.5
playersAllInRange[3][4] = 30.5
-- sb
playersAllInRange[2] = {}
playersAllInRange[2][1] = 59
playersAllInRange[2][2] = 52
playersAllInRange[2][3] = 45
playersAllInRange[2][4] = 42

--otherPlayerCallRange
--倒数
playersCallAllInRange = {}
playersCallAllInRange[4] = {}
playersCallAllInRange[3] = {}
playersCallAllInRange[2] = {}
playersCallAllInRange[1] = {}

playersCallAllInRange[4][3] = {}
playersCallAllInRange[4][2] = {}
playersCallAllInRange[4][1] = {}
playersCallAllInRange[3][2] = {}
playersCallAllInRange[3][1] = {}
playersCallAllInRange[2][1] = {}

-- co btn
playersCallAllInRange[4][3][1] = 15
playersCallAllInRange[4][3][2] = 13
playersCallAllInRange[4][3][3] = 12
playersCallAllInRange[4][3][4] = 12
-- co sb
playersCallAllInRange[4][2][1] = 18
playersCallAllInRange[4][2][2] = 16
playersCallAllInRange[4][2][3] = 14
playersCallAllInRange[4][2][4] = 12
-- co bb
playersCallAllInRange[4][1][1] = 19.5
playersCallAllInRange[4][1][2] = 18
playersCallAllInRange[4][1][3] = 16
playersCallAllInRange[4][1][4] = 16
-- btn sb
playersCallAllInRange[3][2][1] = 22
playersCallAllInRange[3][2][2] = 21
playersCallAllInRange[3][2][3] = 19.5
playersCallAllInRange[3][2][4] = 18
-- btn bb
playersCallAllInRange[3][1][1] = 26.5
playersCallAllInRange[3][1][2] = 24.5
playersCallAllInRange[3][1][3] = 22.5
playersCallAllInRange[3][1][4] = 21
-- sb bb
playersCallAllInRange[2][1][1] = 41
playersCallAllInRange[2][1][2] = 39
playersCallAllInRange[2][1][3] = 29
playersCallAllInRange[2][1][4] = 29

PLAYER_POSITION_NAME = {}
PLAYER_POSITION_NAME[1] = "btn"
PLAYER_POSITION_NAME[2] = "sb"
PLAYER_POSITION_NAME[3] = "bb"
PLAYER_POSITION_NAME[4] = "co"



PLAYER_STACK_INDEX = {}
PLAYER_STACK_INDEX[7] = 1
PLAYER_STACK_INDEX[8] = 1
PLAYER_STACK_INDEX[9] = 1
PLAYER_STACK_INDEX[10] = 2
PLAYER_STACK_INDEX[11] = 2
PLAYER_STACK_INDEX[12] = 3
PLAYER_STACK_INDEX[13] = 3
PLAYER_STACK_INDEX[14] = 4
PLAYER_STACK_INDEX[15] = 4
PLAYER_STACK_INDEX[16] = 4


---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by yd.
--- DateTime: 2019-07-01 17:50
---

-- ========== Settings ================
Settings:setCompareDimension(true, 1080)
Settings:setScriptDimension(true, 1080)
Settings:set("MinSimilarity", 0.9)
Settings:set('AutoWaitTimeout', 0)

localPath = scriptPath()
if prodEnv then
    shortUserPasswordDialogStart()
else
    dofile(localPath.."aofFunction.lua")
    dofile(localPath.."function.lua")
    dofile(localPath.."functionV2.lua")
    dofile(localPath.."logFunction.lua")
    dofile(localPath.."locations.lua")
    dofile(localPath.."param.lua")
    dofile(localPath.."settingWithDialog.lua")
    dofile(localPath.."ppkAofFunction.lua")
    dofile(localPath.."ppkShortFunction.lua")
    dofile(localPath.."shortMainFunction.lua")
    dofile(localPath.."utils.lua")

    dofile(localPath.."holdemCalv2/holdemCalcV2.lua")
    dofile(localPath.."holdemCalv2/rangeCalcV2.lua")
    dofile(localPath.."holdemCalv2/initV2Data.lua")
    dofile(localPath.."holdemCalv2/V2ActionMain.lua")
    --
    --dofile(localPath.."holdemCalv2/data/Sklansky.lua")
    --dofile(localPath.."holdemCalv2/data/overcallRange.lua")
    --dofile(localPath.."holdemCalv2/data/otherPlayerCallRange.lua")
    dofile(localPath.."holdemCalv2/data/spotRangeTable.lua")
    --
    --dofile(localPath.."holdemCalv1/holdemCalV1.lua")
    --dofile(localPath.."holdemCalv1/data/allin.lua")
    --dofile(localPath.."holdemCalv1/data/call1player.lua")
    --dofile(localPath.."holdemCalv1/data/call2players.lua")


    dofile(localPath.."shortCalvProject/ppkLocationsShort.lua")
    dofile(localPath.."shortCalvProject/recognitionFunction.lua")
    dofile(localPath.."shortCalvProject/shortMainLoopFunction.lua")
    dofile(localPath.."shortCalvProject/shortParam.lua")
    dofile(localPath.."shortCalvProject/shortV1.lua")
    dofile(localPath.."shortCalvProject/shortV1DataInit.lua")

    dofile(localPath.."common/md5.lua")

    dialogStart("PokerKing")
end

formatShortV1PreflopData("shortCalvProject/data/test3.txt")

--initV1(allinOriginStrategyTable, allinOriginHitTable, allInRangeTable, allInHitTable)
--initV1(call1OriginStrategyTable, call1OriginHitTable, call1RangeTable, call1HitTable)
--initV1(call2OriginStrategyTable, call2OriginHitTable, call2RangeTable, call2HitTable)
--
--formatRangeDataFile("holdemCalv2/data/fileRes")
--initRangeTableV2IncrementVer()
--
--friendsAccountInit()

LogFile("program start")
toast(" PokerKing short program start", 3)
wait(3)


if directPlay then
    while(1) do
        local startTime = os.time()
        local endTime = startTime+111111
        local message, cnt = ppkShortMainLoop(endTime)
        statisticLog("aof bb: "..wantedBbSize..", hands play: "..cnt)
        existsClick(chipSlotImg, 2)
    end
end

local  lastFindTableTime = os.time()

while(1) do
    local startTime = os.time()
    local workingTime = math.random(playMinTimeInMin*60, playMaxTimeInMin*60)
    local endTime = startTime+workingTime

    ppkCheckDisconnect()
    local findTable = getOnTableAof(wantedBbSize)

    --httpGet("https://maker.ifttt.com/trigger/autoBotTest/with/key/nfeLorbq9gn25evEb8mS_2N0QDwxcG6JUHMwShgM9w1?value1=ppk_"..playerId.."_start_workingTime_"..workingTime)

    if findTable then
        statisticLog("ppk aof find table bb: "..wantedBbSize..", playerId: "..playerId)
        toast("findTable", 5)
        LogFile("program start workingTime "..workingTime)

        wait(3)

        existsClick(chipSlotImg, 2)

        local message,cnt,nextRoundWaitTimeMinute = aofMainLoop(endTime)
        statisticLog("ppk aof bb: "..wantedBbSize..", hands play: "..cnt..", playerId: "..playerId)

        exitTable()
        toast("exitTable", 5)
        local restartTime = os.time()+workingTime*sleepTimeCoef

        if nextRoundWaitTimeMinute ~= nil and nextRoundWaitTimeMinute > 0 then
            restartTime = nextRoundWaitTimeMinute*60
        else
            restartTime = os.time()+workingTime*sleepTimeCoef
        end
        toast("restartTime"..restartTime, 5)
        while(1) do
            if os.time() < restartTime then
                wait(10)
                local info = restartTime-os.time().." seconds to go next round"
                LogFile(info)
                toast(info)
            else
                break
            end
        end
        if ppkShort then
            local res = getOnTableShort(wantedBbSize)
            LogFile("short start workingTime "..30)
            if res then
                message = shortMainLoop(os.time()+100)
            end
            statisticLog("ppk short , playerId: "..playerId)

            exitTable()
        end
        lastFindTableTime = os.time()
    else
        errorLog("can not get on table, wait ")
        --wait(200)
        --if os.time() - lastFindTableTime > 600 then
            Snapshot("notFindTableTime_name_"..playerId)
        --end
    end


end